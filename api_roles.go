/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RolesAPIService RolesAPI service
type RolesAPIService service

type ApiAdminRealmsRealmClientsClientUuidRolesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	briefRepresentation *bool
	first *int32
	max *int32
	search *string
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesGetRequest) First(first int32) ApiAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.first = &first
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesGetRequest) Max(max int32) ApiAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesGetRequest) Search(search string) ApiAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesGet Get all roles for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidRolesGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	} else {
		var defaultValue string = ""
		r.search = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleRepresentation *RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesPostRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidRolesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesPost Create a new role for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesPost(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidRolesPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesPostExecute(r ApiAdminRealmsRealmClientsClientUuidRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGet Get client-level roles for the client that are in the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDelete Remove roles from the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDelete(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGet Get composites of the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPost Add a composite to the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPost(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGet Get realm-level roles of the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameDelete Delete a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameDelete(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest) Execute() (*RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameGet Get a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest) (*RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	briefRepresentation *bool
	first *int32
	max *int32
}

// if false, return a full representation of the {@code GroupRepresentation} objects.
func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) First(first int32) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) Max(max int32) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGet Returns a stream of groups that have the specified role name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName the role name.
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGet Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	managementPermissionReference *ManagementPermissionReference
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPut Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPut(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	roleRepresentation *RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNamePutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNamePut Update a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNamePut(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNamePutExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	first *int32
	max *int32
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) First(first int32) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) Max(max int32) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGet Returns a stream of users that have the specified role name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName the role name.
 @return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []UserRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetExecute(r ApiAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	briefRepresentation *bool
	first *int32
	max *int32
	search *string
}

func (r ApiAdminRealmsRealmRolesGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmRolesGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmRolesGetRequest) First(first int32) ApiAdminRealmsRealmRolesGetRequest {
	r.first = &first
	return r
}

func (r ApiAdminRealmsRealmRolesGetRequest) Max(max int32) ApiAdminRealmsRealmRolesGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmRolesGetRequest) Search(search string) ApiAdminRealmsRealmRolesGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmRolesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesGetExecute(r)
}

/*
AdminRealmsRealmRolesGet Get all roles for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmRolesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesGet(ctx context.Context, realm string) ApiAdminRealmsRealmRolesGetRequest {
	return ApiAdminRealmsRealmRolesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesGetExecute(r ApiAdminRealmsRealmRolesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	} else {
		var defaultValue string = ""
		r.search = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleRepresentation *RoleRepresentation
}

func (r ApiAdminRealmsRealmRolesPostRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiAdminRealmsRealmRolesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesPostExecute(r)
}

/*
AdminRealmsRealmRolesPost Create a new role for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmRolesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesPost(ctx context.Context, realm string) ApiAdminRealmsRealmRolesPostRequest {
	return ApiAdminRealmsRealmRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesPostExecute(r ApiAdminRealmsRealmRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r ApiAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGet Get client-level roles for the client that are in the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGet(ctx context.Context, realm string, clientUuid string, roleName string) ApiAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest {
	return ApiAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetExecute(r ApiAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesDeleteExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesDelete Remove roles from the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesDelete(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest {
	return ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesDeleteExecute(r ApiAdminRealmsRealmRolesRoleNameCompositesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameCompositesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r ApiAdminRealmsRealmRolesRoleNameCompositesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesGet Get composites of the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNameCompositesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesGet(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameCompositesGetRequest {
	return ApiAdminRealmsRealmRolesRoleNameCompositesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesGetExecute(r ApiAdminRealmsRealmRolesRoleNameCompositesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesPostExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesPost Add a composite to the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesPost(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest {
	return ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesPostExecute(r ApiAdminRealmsRealmRolesRoleNameCompositesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r ApiAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesRealmGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesRealmGet Get realm-level roles of the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesRealmGet(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest {
	return ApiAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesRealmGetExecute(r ApiAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r ApiAdminRealmsRealmRolesRoleNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameDeleteExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameDelete Delete a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNameDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameDelete(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameDeleteRequest {
	return ApiAdminRealmsRealmRolesRoleNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameDeleteExecute(r ApiAdminRealmsRealmRolesRoleNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r ApiAdminRealmsRealmRolesRoleNameGetRequest) Execute() (*RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameGet Get a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNameGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGet(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameGetRequest {
	return ApiAdminRealmsRealmRolesRoleNameGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGetExecute(r ApiAdminRealmsRealmRolesRoleNameGetRequest) (*RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	briefRepresentation *bool
	first *int32
	max *int32
}

// if false, return a full representation of the {@code GroupRepresentation} objects.
func (r ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest) First(first int32) ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest) Max(max int32) ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameGroupsGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameGroupsGet Returns a stream of groups that have the specified role name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName the role name.
 @return ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGroupsGet(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	return ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGroupsGetExecute(r ApiAdminRealmsRealmRolesRoleNameGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r ApiAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameManagementPermissionsGet Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName
 @return ApiAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsGet(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest {
	return ApiAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsGetExecute(r ApiAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	managementPermissionReference *ManagementPermissionReference
}

func (r ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameManagementPermissionsPut Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName
 @return ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsPut(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest {
	return ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsPutExecute(r ApiAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNamePutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	roleRepresentation *RoleRepresentation
}

func (r ApiAdminRealmsRealmRolesRoleNamePutRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiAdminRealmsRealmRolesRoleNamePutRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmRolesRoleNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNamePutExecute(r)
}

/*
AdminRealmsRealmRolesRoleNamePut Update a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return ApiAdminRealmsRealmRolesRoleNamePutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNamePut(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNamePutRequest {
	return ApiAdminRealmsRealmRolesRoleNamePutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNamePutExecute(r ApiAdminRealmsRealmRolesRoleNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmRolesRoleNameUsersGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	first *int32
	max *int32
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmRolesRoleNameUsersGetRequest) First(first int32) ApiAdminRealmsRealmRolesRoleNameUsersGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiAdminRealmsRealmRolesRoleNameUsersGetRequest) Max(max int32) ApiAdminRealmsRealmRolesRoleNameUsersGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmRolesRoleNameUsersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameUsersGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameUsersGet Returns a stream of users that have the specified role name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName the role name.
 @return ApiAdminRealmsRealmRolesRoleNameUsersGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameUsersGet(ctx context.Context, realm string, roleName string) ApiAdminRealmsRealmRolesRoleNameUsersGetRequest {
	return ApiAdminRealmsRealmRolesRoleNameUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []UserRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameUsersGetExecute(r ApiAdminRealmsRealmRolesRoleNameUsersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
