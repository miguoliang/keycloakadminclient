/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ScopeMappingsAPIService ScopeMappingsAPI service
type ScopeMappingsAPIService service

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGet The available client-level roles Returns the roles for the client that can be associated with the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGet(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGet Get effective client roles Returns the roles for the client that are associated with the client's scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGet(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDelete Remove client-level roles from the client's scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDelete(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGet Get the roles associated with a client's scope Returns roles for the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGet(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPost Add client-level roles to the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPost(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGet Get all scope mappings for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest

Deprecated
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return MappingsRepresentation
// Deprecated
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGet Get realm-level roles that are available to attach to this client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGet Get effective realm-level roles associated with the clientâ€™s scope What this does is recurse any composite roles associated with the clientâ€™s scope and adds the roles to this lists.

The method is really to show a comprehensive total view of realm-level roles associated with the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDelete Remove a set of realm-level roles from the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDelete(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGet Get realm-level roles associated with the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPost Add a set of realm-level roles to the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPost(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest {
	return ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostExecute(r ApiAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGet The available client-level roles Returns the roles for the client that can be associated with the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGet(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGet Get effective client roles Returns the roles for the client that are associated with the client's scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGet(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDelete Remove client-level roles from the client's scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDelete(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGet Get the roles associated with a client's scope Returns roles for the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGet(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	client string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPost Add client-level roles to the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @param client
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPost(ctx context.Context, realm string, clientScopeId string, client string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
		client: client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGet Get all scope mappings for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest

Deprecated
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return MappingsRepresentation
// Deprecated
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGet Get realm-level roles that are available to attach to this client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGet Get effective realm-level roles associated with the clientâ€™s scope What this does is recurse any composite roles associated with the clientâ€™s scope and adds the roles to this lists.

The method is really to show a comprehensive total view of realm-level roles associated with the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDelete Remove a set of realm-level roles from the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDelete(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGet Get realm-level roles associated with the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGet(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientScopeId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPost Add a set of realm-level roles to the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPost(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest {
	return ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostExecute(r ApiAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	client string
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGet The available client-level roles Returns the roles for the client that can be associated with the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param client
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGet(ctx context.Context, realm string, clientUuid string, client string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	client string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGet Get effective client roles Returns the roles for the client that are associated with the client's scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param client
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGet(ctx context.Context, realm string, clientUuid string, client string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	client string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDelete Remove client-level roles from the client's scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param client
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDelete(ctx context.Context, realm string, clientUuid string, client string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		client: client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	client string
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGet Get the roles associated with a client's scope Returns roles for the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param client
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGet(ctx context.Context, realm string, clientUuid string, client string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		client: client,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	client string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPost Add client-level roles to the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param client
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPost(ctx context.Context, realm string, clientUuid string, client string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		client: client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsGet Get all scope mappings for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest

Deprecated
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return MappingsRepresentation
// Deprecated
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsGetExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGet Get realm-level roles that are available to attach to this client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGet Get effective realm-level roles associated with the clientâ€™s scope What this does is recurse any composite roles associated with the clientâ€™s scope and adds the roles to this lists.

The method is really to show a comprehensive total view of realm-level roles associated with the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmDelete Remove a set of realm-level roles from the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmDelete(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmGet Get realm-level roles associated with the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmGetExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest struct {
	ctx context.Context
	ApiService *ScopeMappingsAPIService
	realm string
	clientUuid string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmPost Add a set of realm-level roles to the client's scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmPost(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmPostExecute(r ApiAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
