/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AuthenticationManagementAPIService AuthenticationManagementAPI service
type AuthenticationManagementAPIService service

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationAuthenticatorProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationAuthenticatorProvidersGet Get authenticator providers Returns a stream of authenticator providers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationAuthenticatorProvidersGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationAuthenticatorProvidersGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationAuthenticatorProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/authenticator-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGet Get client authenticator providers Returns a stream of client authenticator providers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/client-authenticator-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	providerId string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest) Execute() (*AuthenticatorConfigInfoRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGet Get authenticator provider's configuration description

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param providerId
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGet(ctx context.Context, realm string, providerId string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		providerId: providerId,
	}
}

// Execute executes the request
//
//	@return AuthenticatorConfigInfoRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest) (*AuthenticatorConfigInfoRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorConfigInfoRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config-description/{providerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"providerId"+"}", url.PathEscape(parameterValueToString(r.providerId, "providerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdDeleteRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	id         string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigIdDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigIdDelete Delete authenticator configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id Configuration id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdDelete(ctx context.Context, realm string, id string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdDeleteRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdDeleteExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	id         string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdGetRequest) Execute() (*AuthenticatorConfigRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigIdGet Get authenticator configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id Configuration id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdGet(ctx context.Context, realm string, id string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AuthenticatorConfigRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdGetRequest) (*AuthenticatorConfigRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorConfigRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest struct {
	ctx                               context.Context
	ApiService                        *AuthenticationManagementAPIService
	realm                             string
	id                                string
	authenticatorConfigRepresentation *AuthenticatorConfigRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest) AuthenticatorConfigRepresentation(authenticatorConfigRepresentation AuthenticatorConfigRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest {
	r.authenticatorConfigRepresentation = &authenticatorConfigRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigIdPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigIdPut Update authenticator configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id Configuration id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdPut(ctx context.Context, realm string, id string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdPutExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest struct {
	ctx                               context.Context
	ApiService                        *AuthenticationManagementAPIService
	realm                             string
	authenticatorConfigRepresentation *AuthenticatorConfigRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest) AuthenticatorConfigRepresentation(authenticatorConfigRepresentation AuthenticatorConfigRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest {
	r.authenticatorConfigRepresentation = &authenticatorConfigRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigPost Create new authenticator configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest

Deprecated
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigPost(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
// Deprecated
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationConfigPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	executionId string
	id          string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest) Execute() (*AuthenticatorConfigRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet Get execution's configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param executionId Execution id
	@param id Configuration id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest

Deprecated
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet(ctx context.Context, realm string, executionId string, id string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest{
		ApiService:  a,
		ctx:         ctx,
		realm:       realm,
		executionId: executionId,
		id:          id,
	}
}

// Execute executes the request
//
//	@return AuthenticatorConfigRepresentation
//
// Deprecated
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest) (*AuthenticatorConfigRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorConfigRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest struct {
	ctx                               context.Context
	ApiService                        *AuthenticationManagementAPIService
	realm                             string
	executionId                       string
	authenticatorConfigRepresentation *AuthenticatorConfigRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest) AuthenticatorConfigRepresentation(authenticatorConfigRepresentation AuthenticatorConfigRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest {
	r.authenticatorConfigRepresentation = &authenticatorConfigRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost Update execution with new configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param executionId Execution id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost(ctx context.Context, realm string, executionId string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest{
		ApiService:  a,
		ctx:         ctx,
		realm:       realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	executionId string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdDelete Delete execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param executionId Execution id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdDelete(ctx context.Context, realm string, executionId string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest{
		ApiService:  a,
		ctx:         ctx,
		realm:       realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	executionId string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdGet Get Single Execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param executionId
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdGet(ctx context.Context, realm string, executionId string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest{
		ApiService:  a,
		ctx:         ctx,
		realm:       realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	executionId string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost Lower execution's priority

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param executionId Execution id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost(ctx context.Context, realm string, executionId string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest{
		ApiService:  a,
		ctx:         ctx,
		realm:       realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/lower-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	executionId string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost Raise execution's priority

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param executionId Execution id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost(ctx context.Context, realm string, executionId string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest{
		ApiService:  a,
		ctx:         ctx,
		realm:       realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/raise-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest struct {
	ctx                                   context.Context
	ApiService                            *AuthenticationManagementAPIService
	realm                                 string
	authenticationExecutionRepresentation *AuthenticationExecutionRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest) AuthenticationExecutionRepresentation(authenticationExecutionRepresentation AuthenticationExecutionRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest {
	r.authenticationExecutionRepresentation = &authenticationExecutionRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsPost Add new authentication execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsPost(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationExecutionsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationExecutionRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	flowAlias   string
	requestBody *map[string]string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest) RequestBody(requestBody map[string]string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPost Copy existing authentication flow under a new name The new name is given as 'newName' attribute of the passed JSON object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param flowAlias name of the existing authentication flow
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPost(ctx context.Context, realm string, flowAlias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		flowAlias:  flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	flowAlias   string
	requestBody *map[string]string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest) RequestBody(requestBody map[string]string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost Add new authentication execution to a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param flowAlias Alias of parent flow
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost(ctx context.Context, realm string, flowAlias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		flowAlias:  flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions/execution"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	flowAlias   string
	requestBody *map[string]string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest) RequestBody(requestBody map[string]string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost Add new flow with new execution to existing flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param flowAlias Alias of parent authentication flow
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost(ctx context.Context, realm string, flowAlias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		flowAlias:  flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions/flow"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	flowAlias  string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet Get authentication executions for a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param flowAlias Flow alias
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet(ctx context.Context, realm string, flowAlias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		flowAlias:  flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest struct {
	ctx                                       context.Context
	ApiService                                *AuthenticationManagementAPIService
	realm                                     string
	flowAlias                                 string
	authenticationExecutionInfoRepresentation *AuthenticationExecutionInfoRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest) AuthenticationExecutionInfoRepresentation(authenticationExecutionInfoRepresentation AuthenticationExecutionInfoRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest {
	r.authenticationExecutionInfoRepresentation = &authenticationExecutionInfoRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut Update authentication executions of a Flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param flowAlias Flow alias
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut(ctx context.Context, realm string, flowAlias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		flowAlias:  flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationExecutionInfoRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsGetRequest) Execute() ([]AuthenticationFlowRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsGet Get authentication flows Returns a stream of authentication flows.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []AuthenticationFlowRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsGetRequest) ([]AuthenticationFlowRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AuthenticationFlowRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdDeleteRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	id         string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsIdDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsIdDelete Delete an authentication flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id Flow id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdDelete(ctx context.Context, realm string, id string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdDeleteRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdDeleteExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	id         string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdGetRequest) Execute() (*AuthenticationFlowRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsIdGet Get authentication flow for id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id Flow id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdGet(ctx context.Context, realm string, id string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AuthenticationFlowRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdGetRequest) (*AuthenticationFlowRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticationFlowRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest struct {
	ctx                              context.Context
	ApiService                       *AuthenticationManagementAPIService
	realm                            string
	id                               string
	authenticationFlowRepresentation *AuthenticationFlowRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest) AuthenticationFlowRepresentation(authenticationFlowRepresentation AuthenticationFlowRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest {
	r.authenticationFlowRepresentation = &authenticationFlowRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsIdPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsIdPut Update an authentication flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdPut(ctx context.Context, realm string, id string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdPutExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationFlowRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest struct {
	ctx                              context.Context
	ApiService                       *AuthenticationManagementAPIService
	realm                            string
	authenticationFlowRepresentation *AuthenticationFlowRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest) AuthenticationFlowRepresentation(authenticationFlowRepresentation AuthenticationFlowRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest {
	r.authenticationFlowRepresentation = &authenticationFlowRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsPost Create a new authentication flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsPost(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFlowsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationFlowRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormActionProvidersGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormActionProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFormActionProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFormActionProvidersGet Get form action providers Returns a stream of form action providers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormActionProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormActionProvidersGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormActionProvidersGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormActionProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormActionProvidersGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormActionProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFormActionProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/form-action-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormProvidersGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFormProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFormProvidersGet Get form providers Returns a stream of form providers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormProvidersGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormProvidersGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormProvidersGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationFormProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFormProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/form-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest) Execute() (*map[string][]ConfigPropertyRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationPerClientConfigDescriptionGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationPerClientConfigDescriptionGet Get configuration descriptions for all clients

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationPerClientConfigDescriptionGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return map[string][]ConfigPropertyRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationPerClientConfigDescriptionGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest) (*map[string][]ConfigPropertyRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string][]ConfigPropertyRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationPerClientConfigDescriptionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/per-client-config-description"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest struct {
	ctx         context.Context
	ApiService  *AuthenticationManagementAPIService
	realm       string
	requestBody *map[string]string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest) RequestBody(requestBody map[string]string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRegisterRequiredActionPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationRegisterRequiredActionPost Register a new required actions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRegisterRequiredActionPost(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRegisterRequiredActionPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRegisterRequiredActionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/register-required-action"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	alias      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasDelete Delete required action

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param alias Alias of required action
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasDelete(ctx context.Context, realm string, alias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		alias:      alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasDeleteExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	alias      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest) Execute() (*RequiredActionProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasGet Get required action for alias

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param alias Alias of required action
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasGet(ctx context.Context, realm string, alias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		alias:      alias,
	}
}

// Execute executes the request
//
//	@return RequiredActionProviderRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest) (*RequiredActionProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RequiredActionProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	alias      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost Lower required action's priority

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param alias Alias of required action
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost(ctx context.Context, realm string, alias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		alias:      alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}/lower-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest struct {
	ctx                                  context.Context
	ApiService                           *AuthenticationManagementAPIService
	realm                                string
	alias                                string
	requiredActionProviderRepresentation *RequiredActionProviderRepresentation
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest) RequiredActionProviderRepresentation(requiredActionProviderRepresentation RequiredActionProviderRepresentation) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest {
	r.requiredActionProviderRepresentation = &requiredActionProviderRepresentation
	return r
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasPut Update required action

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param alias Alias of required action
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasPut(ctx context.Context, realm string, alias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		alias:      alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasPutExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requiredActionProviderRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
	alias      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost Raise required action's priority

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param alias Alias of required action
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost(ctx context.Context, realm string, alias string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		alias:      alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}/raise-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsGetRequest) Execute() ([]RequiredActionProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsGet Get required actions Returns a stream of required actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []RequiredActionProviderRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationRequiredActionsGetRequest) ([]RequiredActionProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RequiredActionProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthenticationManagementAPIAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest struct {
	ctx        context.Context
	ApiService *AuthenticationManagementAPIService
	realm      string
}

func (r AuthenticationManagementAPIAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest) Execute() ([]map[string]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGet Get unregistered required actions Returns a stream of unregistered required actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return AuthenticationManagementAPIAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGet(ctx context.Context, realm string) AuthenticationManagementAPIAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest {
	return AuthenticationManagementAPIAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []map[string]string
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetExecute(r AuthenticationManagementAPIAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest) ([]map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/unregistered-required-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
