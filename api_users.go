/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// UsersAPIService UsersAPI service
type UsersAPIService service

type ApiAdminRealmsRealmUsersCountGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	email *string
	emailVerified *bool
	enabled *bool
	firstName *string
	lastName *string
	q *string
	search *string
	username *string
}

// email filter
func (r ApiAdminRealmsRealmUsersCountGetRequest) Email(email string) ApiAdminRealmsRealmUsersCountGetRequest {
	r.email = &email
	return r
}

func (r ApiAdminRealmsRealmUsersCountGetRequest) EmailVerified(emailVerified bool) ApiAdminRealmsRealmUsersCountGetRequest {
	r.emailVerified = &emailVerified
	return r
}

// Boolean representing if user is enabled or not
func (r ApiAdminRealmsRealmUsersCountGetRequest) Enabled(enabled bool) ApiAdminRealmsRealmUsersCountGetRequest {
	r.enabled = &enabled
	return r
}

// first name filter
func (r ApiAdminRealmsRealmUsersCountGetRequest) FirstName(firstName string) ApiAdminRealmsRealmUsersCountGetRequest {
	r.firstName = &firstName
	return r
}

// last name filter
func (r ApiAdminRealmsRealmUsersCountGetRequest) LastName(lastName string) ApiAdminRealmsRealmUsersCountGetRequest {
	r.lastName = &lastName
	return r
}

func (r ApiAdminRealmsRealmUsersCountGetRequest) Q(q string) ApiAdminRealmsRealmUsersCountGetRequest {
	r.q = &q
	return r
}

// arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search.
func (r ApiAdminRealmsRealmUsersCountGetRequest) Search(search string) ApiAdminRealmsRealmUsersCountGetRequest {
	r.search = &search
	return r
}

// username filter
func (r ApiAdminRealmsRealmUsersCountGetRequest) Username(username string) ApiAdminRealmsRealmUsersCountGetRequest {
	r.username = &username
	return r
}

func (r ApiAdminRealmsRealmUsersCountGetRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersCountGetExecute(r)
}

/*
AdminRealmsRealmUsersCountGet Returns the number of users that match the given criteria.

It can be called in three different ways. 1. Donâ€™t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. <p> 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. <p> 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersCountGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersCountGet(ctx context.Context, realm string) ApiAdminRealmsRealmUsersCountGetRequest {
	return ApiAdminRealmsRealmUsersCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return int32
func (a *UsersAPIService) AdminRealmsRealmUsersCountGetExecute(r ApiAdminRealmsRealmUsersCountGetRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.emailVerified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailVerified", r.emailVerified, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	briefRepresentation *bool
	email *string
	emailVerified *bool
	enabled *bool
	exact *bool
	first *int32
	firstName *string
	idpAlias *string
	idpUserId *string
	lastName *string
	max *int32
	q *string
	search *string
	username *string
}

// Boolean which defines whether brief representations are returned (default: false)
func (r ApiAdminRealmsRealmUsersGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmUsersGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// A String contained in email, or the complete email, if param \&quot;exact\&quot; is true
func (r ApiAdminRealmsRealmUsersGetRequest) Email(email string) ApiAdminRealmsRealmUsersGetRequest {
	r.email = &email
	return r
}

// whether the email has been verified
func (r ApiAdminRealmsRealmUsersGetRequest) EmailVerified(emailVerified bool) ApiAdminRealmsRealmUsersGetRequest {
	r.emailVerified = &emailVerified
	return r
}

// Boolean representing if user is enabled or not
func (r ApiAdminRealmsRealmUsersGetRequest) Enabled(enabled bool) ApiAdminRealmsRealmUsersGetRequest {
	r.enabled = &enabled
	return r
}

// Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly
func (r ApiAdminRealmsRealmUsersGetRequest) Exact(exact bool) ApiAdminRealmsRealmUsersGetRequest {
	r.exact = &exact
	return r
}

// Pagination offset
func (r ApiAdminRealmsRealmUsersGetRequest) First(first int32) ApiAdminRealmsRealmUsersGetRequest {
	r.first = &first
	return r
}

// A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true
func (r ApiAdminRealmsRealmUsersGetRequest) FirstName(firstName string) ApiAdminRealmsRealmUsersGetRequest {
	r.firstName = &firstName
	return r
}

// The alias of an Identity Provider linked to the user
func (r ApiAdminRealmsRealmUsersGetRequest) IdpAlias(idpAlias string) ApiAdminRealmsRealmUsersGetRequest {
	r.idpAlias = &idpAlias
	return r
}

// The userId at an Identity Provider linked to the user
func (r ApiAdminRealmsRealmUsersGetRequest) IdpUserId(idpUserId string) ApiAdminRealmsRealmUsersGetRequest {
	r.idpUserId = &idpUserId
	return r
}

// A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true
func (r ApiAdminRealmsRealmUsersGetRequest) LastName(lastName string) ApiAdminRealmsRealmUsersGetRequest {
	r.lastName = &lastName
	return r
}

// Maximum results size (defaults to 100)
func (r ApiAdminRealmsRealmUsersGetRequest) Max(max int32) ApiAdminRealmsRealmUsersGetRequest {
	r.max = &max
	return r
}

// A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39;
func (r ApiAdminRealmsRealmUsersGetRequest) Q(q string) ApiAdminRealmsRealmUsersGetRequest {
	r.q = &q
	return r
}

// A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search.
func (r ApiAdminRealmsRealmUsersGetRequest) Search(search string) ApiAdminRealmsRealmUsersGetRequest {
	r.search = &search
	return r
}

// A String contained in username, or the complete username, if param \&quot;exact\&quot; is true
func (r ApiAdminRealmsRealmUsersGetRequest) Username(username string) ApiAdminRealmsRealmUsersGetRequest {
	r.username = &username
	return r
}

func (r ApiAdminRealmsRealmUsersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersGetExecute(r)
}

/*
AdminRealmsRealmUsersGet Get users Returns a stream of users, filtered according to query parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersGet(ctx context.Context, realm string) ApiAdminRealmsRealmUsersGetRequest {
	return ApiAdminRealmsRealmUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []UserRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersGetExecute(r ApiAdminRealmsRealmUsersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.emailVerified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailVerified", r.emailVerified, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.idpAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idpAlias", r.idpAlias, "")
	}
	if r.idpUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idpUserId", r.idpUserId, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userRepresentation *UserRepresentation
}

func (r ApiAdminRealmsRealmUsersPostRequest) UserRepresentation(userRepresentation UserRepresentation) ApiAdminRealmsRealmUsersPostRequest {
	r.userRepresentation = &userRepresentation
	return r
}

func (r ApiAdminRealmsRealmUsersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersPostExecute(r)
}

/*
AdminRealmsRealmUsersPost Create a new user Username must be unique.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersPost(ctx context.Context, realm string) ApiAdminRealmsRealmUsersPostRequest {
	return ApiAdminRealmsRealmUsersPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersPostExecute(r ApiAdminRealmsRealmUsersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersProfileGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
}

func (r ApiAdminRealmsRealmUsersProfileGetRequest) Execute() (*UPConfig, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersProfileGetExecute(r)
}

/*
AdminRealmsRealmUsersProfileGet Method for AdminRealmsRealmUsersProfileGet

Get the configuration for the user profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersProfileGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersProfileGet(ctx context.Context, realm string) ApiAdminRealmsRealmUsersProfileGetRequest {
	return ApiAdminRealmsRealmUsersProfileGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return UPConfig
func (a *UsersAPIService) AdminRealmsRealmUsersProfileGetExecute(r ApiAdminRealmsRealmUsersProfileGetRequest) (*UPConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UPConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersProfileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersProfileMetadataGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
}

func (r ApiAdminRealmsRealmUsersProfileMetadataGetRequest) Execute() (*UserProfileMetadata, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersProfileMetadataGetExecute(r)
}

/*
AdminRealmsRealmUsersProfileMetadataGet Method for AdminRealmsRealmUsersProfileMetadataGet

Get the UserProfileMetadata from the configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersProfileMetadataGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersProfileMetadataGet(ctx context.Context, realm string) ApiAdminRealmsRealmUsersProfileMetadataGetRequest {
	return ApiAdminRealmsRealmUsersProfileMetadataGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return UserProfileMetadata
func (a *UsersAPIService) AdminRealmsRealmUsersProfileMetadataGetExecute(r ApiAdminRealmsRealmUsersProfileMetadataGetRequest) (*UserProfileMetadata, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserProfileMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersProfileMetadataGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/profile/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersProfilePutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	uPConfig *UPConfig
}

func (r ApiAdminRealmsRealmUsersProfilePutRequest) UPConfig(uPConfig UPConfig) ApiAdminRealmsRealmUsersProfilePutRequest {
	r.uPConfig = &uPConfig
	return r
}

func (r ApiAdminRealmsRealmUsersProfilePutRequest) Execute() (*UPConfig, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersProfilePutExecute(r)
}

/*
AdminRealmsRealmUsersProfilePut Method for AdminRealmsRealmUsersProfilePut

Set the configuration for the user profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersProfilePutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersProfilePut(ctx context.Context, realm string) ApiAdminRealmsRealmUsersProfilePutRequest {
	return ApiAdminRealmsRealmUsersProfilePutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return UPConfig
func (a *UsersAPIService) AdminRealmsRealmUsersProfilePutExecute(r ApiAdminRealmsRealmUsersProfilePutRequest) (*UPConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UPConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersProfilePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uPConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet Return credential types, which are provided by the user storage where user is stored.

Returned values can contain for example "password", "otp" etc. This will always return empty list for "local" users, which are not backed by any user storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest {
	return ApiAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []string
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetExecute(r ApiAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/configured-user-storage-credential-types"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	client string
}

func (r ApiAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdConsentsClientDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdConsentsClientDelete Revoke consent and offline tokens for particular client from user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param client Client id
 @return ApiAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsClientDelete(ctx context.Context, realm string, userId string, client string) ApiAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest {
	return ApiAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		client: client,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsClientDeleteExecute(r ApiAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdConsentsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/consents/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdConsentsGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdConsentsGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdConsentsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdConsentsGet Get consents granted by the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdConsentsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdConsentsGetRequest {
	return ApiAdminRealmsRealmUsersUserIdConsentsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsGetExecute(r ApiAdminRealmsRealmUsersUserIdConsentsGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdConsentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/consents"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	credentialId string
}

func (r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdDelete Remove a credential for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param credentialId
 @return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdDelete(ctx context.Context, realm string, userId string, credentialId string) ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest {
	return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		credentialId: credentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteExecute(r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	credentialId string
	newPreviousCredentialId string
}

func (r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost Move a credential to a position behind another credential

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param credentialId The credential to move
 @param newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
 @return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(ctx context.Context, realm string, userId string, credentialId string, newPreviousCredentialId string) ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest {
	return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		credentialId: credentialId,
		newPreviousCredentialId: newPreviousCredentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostExecute(r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"newPreviousCredentialId"+"}", url.PathEscape(parameterValueToString(r.newPreviousCredentialId, "newPreviousCredentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	credentialId string
}

func (r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost Move a credential to a first position in the credentials list of the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param credentialId The credential to move
 @return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost(ctx context.Context, realm string, userId string, credentialId string) ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest {
	return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		credentialId: credentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostExecute(r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveToFirst"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	credentialId string
	body *string
}

func (r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest) Body(body string) ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest {
	r.body = &body
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut Update a credential label for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param credentialId
 @return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut(ctx context.Context, realm string, userId string, credentialId string) ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest {
	return ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		credentialId: credentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutExecute(r ApiAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/userLabel"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdCredentialsGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdCredentialsGetRequest) Execute() ([]CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsGet Method for AdminRealmsRealmUsersUserIdCredentialsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdCredentialsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdCredentialsGetRequest {
	return ApiAdminRealmsRealmUsersUserIdCredentialsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []CredentialRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsGetExecute(r ApiAdminRealmsRealmUsersUserIdCredentialsGetRequest) ([]CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdDeleteRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdDelete Delete the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDelete(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdDeleteRequest {
	return ApiAdminRealmsRealmUsersUserIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDeleteExecute(r ApiAdminRealmsRealmUsersUserIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	requestBody *[]string
}

func (r ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest) RequestBody(requestBody []string) ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdDisableCredentialTypesPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdDisableCredentialTypesPut Disable all credentials for a user of a specific type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDisableCredentialTypesPut(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest {
	return ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDisableCredentialTypesPutExecute(r ApiAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdDisableCredentialTypesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/disable-credential-types"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	clientId *string
	lifespan *int32
	redirectUri *string
	requestBody *[]string
}

// Client id
func (r ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) ClientId(clientId string) ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.clientId = &clientId
	return r
}

// Number of seconds after which the generated token expires
func (r ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) Lifespan(lifespan int32) ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.lifespan = &lifespan
	return r
}

// Redirect uri
func (r ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) RedirectUri(redirectUri string) ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.redirectUri = &redirectUri
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) RequestBody(requestBody []string) ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdExecuteActionsEmailPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdExecuteActionsEmailPut Send an email to the user with a link they can click to execute particular actions.

An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdExecuteActionsEmailPut(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	return ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdExecuteActionsEmailPutExecute(r ApiAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdExecuteActionsEmailPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/execute-actions-email"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "")
	}
	if r.lifespan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lifespan", r.lifespan, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redirect_uri", r.redirectUri, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest) Execute() ([]FederatedIdentityRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdFederatedIdentityGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdFederatedIdentityGet Get social logins associated with the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest {
	return ApiAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []FederatedIdentityRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityGetExecute(r ApiAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest) ([]FederatedIdentityRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FederatedIdentityRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdFederatedIdentityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/federated-identity"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	provider string
}

func (r ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdFederatedIdentityProviderDelete Remove a social login provider from user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param provider Social login provider id
 @return ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderDelete(ctx context.Context, realm string, userId string, provider string) ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest {
	return ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		provider: provider,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteExecute(r ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"provider"+"}", url.PathEscape(parameterValueToString(r.provider, "provider")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	provider string
}

func (r ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdFederatedIdentityProviderPost Add a social login provider to the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param provider Social login provider id
 @return ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderPost(ctx context.Context, realm string, userId string, provider string) ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest {
	return ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		provider: provider,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderPostExecute(r ApiAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"provider"+"}", url.PathEscape(parameterValueToString(r.provider, "provider")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	userProfileMetadata *bool
}

// Indicates if the user profile metadata should be added to the response
func (r ApiAdminRealmsRealmUsersUserIdGetRequest) UserProfileMetadata(userProfileMetadata bool) ApiAdminRealmsRealmUsersUserIdGetRequest {
	r.userProfileMetadata = &userProfileMetadata
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdGetRequest) Execute() (*UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGet Get representation of the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdGetRequest {
	return ApiAdminRealmsRealmUsersUserIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGetExecute(r ApiAdminRealmsRealmUsersUserIdGetRequest) (*UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userProfileMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userProfileMetadata", r.userProfileMetadata, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	search *string
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest) Search(search string) ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsCountGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsCountGet Method for AdminRealmsRealmUsersUserIdGroupsCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsCountGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest {
	return ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsCountGetExecute(r ApiAdminRealmsRealmUsersUserIdGroupsCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdGroupsGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	briefRepresentation *bool
	first *int32
	max *int32
	search *string
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsGetRequest) First(first int32) ApiAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.first = &first
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsGetRequest) Max(max int32) ApiAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsGetRequest) Search(search string) ApiAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsGet Method for AdminRealmsRealmUsersUserIdGroupsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdGroupsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdGroupsGetRequest {
	return ApiAdminRealmsRealmUsersUserIdGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGetExecute(r ApiAdminRealmsRealmUsersUserIdGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	groupId string
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsGroupIdDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsGroupIdDelete Method for AdminRealmsRealmUsersUserIdGroupsGroupIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param groupId
 @return ApiAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdDelete(ctx context.Context, realm string, userId string, groupId string) ApiAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest {
	return ApiAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdDeleteExecute(r ApiAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	groupId string
}

func (r ApiAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsGroupIdPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsGroupIdPut Method for AdminRealmsRealmUsersUserIdGroupsGroupIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param groupId
 @return ApiAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdPut(ctx context.Context, realm string, userId string, groupId string) ApiAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest {
	return ApiAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdPutExecute(r ApiAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsGroupIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdImpersonationPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdImpersonationPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdImpersonationPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdImpersonationPost Impersonate the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdImpersonationPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdImpersonationPost(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdImpersonationPostRequest {
	return ApiAdminRealmsRealmUsersUserIdImpersonationPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdImpersonationPostExecute(r ApiAdminRealmsRealmUsersUserIdImpersonationPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdImpersonationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/impersonation"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdLogoutPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdLogoutPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdLogoutPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdLogoutPost Remove all user sessions associated with the user Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdLogoutPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdLogoutPost(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdLogoutPostRequest {
	return ApiAdminRealmsRealmUsersUserIdLogoutPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdLogoutPostExecute(r ApiAdminRealmsRealmUsersUserIdLogoutPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdLogoutPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/logout"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	clientUuid string
}

func (r ApiAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet Get offline sessions associated with the user and client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @param clientUuid
 @return ApiAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet(ctx context.Context, realm string, userId string, clientUuid string) ApiAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest {
	return ApiAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []UserSessionRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetExecute(r ApiAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/offline-sessions/{clientUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientUuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	userRepresentation *UserRepresentation
}

func (r ApiAdminRealmsRealmUsersUserIdPutRequest) UserRepresentation(userRepresentation UserRepresentation) ApiAdminRealmsRealmUsersUserIdPutRequest {
	r.userRepresentation = &userRepresentation
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdPut Update the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdPut(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdPutRequest {
	return ApiAdminRealmsRealmUsersUserIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdPutExecute(r ApiAdminRealmsRealmUsersUserIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	clientId *string
	redirectUri *string
}

// client id
func (r ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) ClientId(clientId string) ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest {
	r.clientId = &clientId
	return r
}

// redirect uri
func (r ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) RedirectUri(redirectUri string) ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest {
	r.redirectUri = &redirectUri
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdResetPasswordEmailPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdResetPasswordEmailPut Send an email to the user with a link they can click to reset their password.

The redirectUri and clientId parameters are optional. The default for the redirect is the account client. This endpoint has been deprecated.  Please use the execute-actions-email passing a list with UPDATE_PASSWORD within it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest

Deprecated
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordEmailPut(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest {
	return ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
// Deprecated
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordEmailPutExecute(r ApiAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdResetPasswordEmailPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/reset-password-email"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redirect_uri", r.redirectUri, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	credentialRepresentation *CredentialRepresentation
}

func (r ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest) CredentialRepresentation(credentialRepresentation CredentialRepresentation) ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest {
	r.credentialRepresentation = &credentialRepresentation
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdResetPasswordPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdResetPasswordPut Set up a new password for the user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordPut(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest {
	return ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordPutExecute(r ApiAdminRealmsRealmUsersUserIdResetPasswordPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdResetPasswordPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/reset-password"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.credentialRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
	clientId *string
	lifespan *int32
	redirectUri *string
}

// Client id
func (r ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) ClientId(clientId string) ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	r.clientId = &clientId
	return r
}

// Number of seconds after which the generated token expires
func (r ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) Lifespan(lifespan int32) ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	r.lifespan = &lifespan
	return r
}

// Redirect uri
func (r ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) RedirectUri(redirectUri string) ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	r.redirectUri = &redirectUri
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdSendVerifyEmailPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdSendVerifyEmailPut Send an email-verification email to the user An email contains a link the user can click to verify their email address.

The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSendVerifyEmailPut(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	return ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSendVerifyEmailPutExecute(r ApiAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdSendVerifyEmailPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/send-verify-email"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "")
	}
	if r.lifespan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lifespan", r.lifespan, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redirect_uri", r.redirectUri, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdSessionsGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdSessionsGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdSessionsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdSessionsGet Get sessions associated with the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdSessionsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSessionsGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdSessionsGetRequest {
	return ApiAdminRealmsRealmUsersUserIdSessionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []UserSessionRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSessionsGetExecute(r ApiAdminRealmsRealmUsersUserIdSessionsGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdSessionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
