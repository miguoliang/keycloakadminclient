/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ScopeMappingsAPIService ScopeMappingsAPI service
type ScopeMappingsAPIService service

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
	client        string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGet The available client-level roles Returns the roles for the client that can be associated with the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGet(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	clientScopeId       string
	client              string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGet Get effective client roles Returns the roles for the client that are associated with the client's scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGet(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	client             string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDelete Remove client-level roles from the client's scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDelete(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
	client        string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGet Get the roles associated with a client's scope Returns roles for the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGet(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	client             string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPost Add client-level roles to the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPost(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsClientsClientPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGet Get all scope mappings for the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest

Deprecated
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return MappingsRepresentation
//
// Deprecated
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGet Get realm-level roles that are available to attach to this client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	clientScopeId       string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGet Get effective realm-level roles associated with the clientâ€™s scope What this does is recurse any composite roles associated with the clientâ€™s scope and adds the roles to this lists.

The method is really to show a comprehensive total view of realm-level roles associated with the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDelete Remove a set of realm-level roles from the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDelete(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGet Get realm-level roles associated with the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPost Add a set of realm-level roles to the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPost(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostExecute(r ScopeMappingsAPIAdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientScopesClientScopeIdScopeMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-scopes/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
	client        string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGet The available client-level roles Returns the roles for the client that can be associated with the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGet(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	clientScopeId       string
	client              string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGet Get effective client roles Returns the roles for the client that are associated with the client's scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGet(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	client             string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDelete Remove client-level roles from the client's scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDelete(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
	client        string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGet Get the roles associated with a client's scope Returns roles for the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGet(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	client             string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPost Add client-level roles to the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPost(ctx context.Context, realm string, clientScopeId string, client string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
		client:        client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsClientsClientPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGet Get all scope mappings for the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest

Deprecated
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return MappingsRepresentation
//
// Deprecated
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGet Get realm-level roles that are available to attach to this client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	clientScopeId       string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGet Get effective realm-level roles associated with the clientâ€™s scope What this does is recurse any composite roles associated with the clientâ€™s scope and adds the roles to this lists.

The method is really to show a comprehensive total view of realm-level roles associated with the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDelete Remove a set of realm-level roles from the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDelete(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest struct {
	ctx           context.Context
	ApiService    *ScopeMappingsAPIService
	realm         string
	clientScopeId string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGet Get realm-level roles associated with the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGet(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientScopeId      string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPost Add a set of realm-level roles to the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientScopeId
	@return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPost(ctx context.Context, realm string, clientScopeId string) ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest{
		ApiService:    a,
		ctx:           ctx,
		realm:         realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostExecute(r ScopeMappingsAPIAdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientTemplatesClientScopeIdScopeMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-templates/{client-scope-id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-scope-id"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	clientUuid string
	client     string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGet The available client-level roles Returns the roles for the client that can be associated with the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGet(ctx context.Context, realm string, clientUuid string, client string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	clientUuid          string
	client              string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGet Get effective client roles Returns the roles for the client that are associated with the client's scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGet(ctx context.Context, realm string, clientUuid string, client string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientUuid         string
	client             string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDelete Remove client-level roles from the client's scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDelete(ctx context.Context, realm string, clientUuid string, client string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	clientUuid string
	client     string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGet Get the roles associated with a client's scope Returns roles for the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGet(ctx context.Context, realm string, clientUuid string, client string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientUuid         string
	client             string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPost Add client-level roles to the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@param client
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPost(ctx context.Context, realm string, clientUuid string, client string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsClientsClientPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	clientUuid string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsGet Get all scope mappings for the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest

Deprecated
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsGet(ctx context.Context, realm string, clientUuid string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//
//	@return MappingsRepresentation
//
// Deprecated
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	clientUuid string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGet Get realm-level roles that are available to attach to this client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGet(ctx context.Context, realm string, clientUuid string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	clientUuid          string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGet Get effective realm-level roles associated with the clientâ€™s scope What this does is recurse any composite roles associated with the clientâ€™s scope and adds the roles to this lists.

The method is really to show a comprehensive total view of realm-level roles associated with the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGet(ctx context.Context, realm string, clientUuid string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientUuid         string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmDelete Remove a set of realm-level roles from the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmDelete(ctx context.Context, realm string, clientUuid string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	clientUuid string
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmGet Get realm-level roles associated with the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmGet(ctx context.Context, realm string, clientUuid string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmGetExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	clientUuid         string
	roleRepresentation *[]RoleRepresentation
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidScopeMappingsRealmPost Add a set of realm-level roles to the client's scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param clientUuid id of client (not client-id!)
	@return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest
*/
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmPost(ctx context.Context, realm string, clientUuid string) ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest {
	return ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) AdminRealmsRealmClientsClientUuidScopeMappingsRealmPostExecute(r ScopeMappingsAPIAdminRealmsRealmClientsClientUuidScopeMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.AdminRealmsRealmClientsClientUuidScopeMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
