/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// UsersAPIService UsersAPI service
type UsersAPIService service

type UsersAPIAdminRealmsRealmUsersCountGetRequest struct {
	ctx           context.Context
	ApiService    *UsersAPIService
	realm         string
	email         *string
	emailVerified *bool
	enabled       *bool
	firstName     *string
	lastName      *string
	q             *string
	search        *string
	username      *string
}

// email filter
func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) Email(email string) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.email = &email
	return r
}

func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) EmailVerified(emailVerified bool) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.emailVerified = &emailVerified
	return r
}

// Boolean representing if user is enabled or not
func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) Enabled(enabled bool) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.enabled = &enabled
	return r
}

// first name filter
func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) FirstName(firstName string) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.firstName = &firstName
	return r
}

// last name filter
func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) LastName(lastName string) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.lastName = &lastName
	return r
}

func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) Q(q string) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.q = &q
	return r
}

// arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search.
func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) Search(search string) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.search = &search
	return r
}

// username filter
func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) Username(username string) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	r.username = &username
	return r
}

func (r UsersAPIAdminRealmsRealmUsersCountGetRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersCountGetExecute(r)
}

/*
AdminRealmsRealmUsersCountGet Returns the number of users that match the given criteria.

It can be called in three different ways. 1. Donâ€™t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. <p> 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. <p> 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return UsersAPIAdminRealmsRealmUsersCountGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersCountGet(ctx context.Context, realm string) UsersAPIAdminRealmsRealmUsersCountGetRequest {
	return UsersAPIAdminRealmsRealmUsersCountGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return int32
func (a *UsersAPIService) AdminRealmsRealmUsersCountGetExecute(r UsersAPIAdminRealmsRealmUsersCountGetRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.emailVerified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailVerified", r.emailVerified, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersGetRequest struct {
	ctx                 context.Context
	ApiService          *UsersAPIService
	realm               string
	briefRepresentation *bool
	email               *string
	emailVerified       *bool
	enabled             *bool
	exact               *bool
	first               *int32
	firstName           *string
	idpAlias            *string
	idpUserId           *string
	lastName            *string
	max                 *int32
	q                   *string
	search              *string
	username            *string
}

// Boolean which defines whether brief representations are returned (default: false)
func (r UsersAPIAdminRealmsRealmUsersGetRequest) BriefRepresentation(briefRepresentation bool) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// A String contained in email, or the complete email, if param \&quot;exact\&quot; is true
func (r UsersAPIAdminRealmsRealmUsersGetRequest) Email(email string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.email = &email
	return r
}

// whether the email has been verified
func (r UsersAPIAdminRealmsRealmUsersGetRequest) EmailVerified(emailVerified bool) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.emailVerified = &emailVerified
	return r
}

// Boolean representing if user is enabled or not
func (r UsersAPIAdminRealmsRealmUsersGetRequest) Enabled(enabled bool) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.enabled = &enabled
	return r
}

// Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly
func (r UsersAPIAdminRealmsRealmUsersGetRequest) Exact(exact bool) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.exact = &exact
	return r
}

// Pagination offset
func (r UsersAPIAdminRealmsRealmUsersGetRequest) First(first int32) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.first = &first
	return r
}

// A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true
func (r UsersAPIAdminRealmsRealmUsersGetRequest) FirstName(firstName string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.firstName = &firstName
	return r
}

// The alias of an Identity Provider linked to the user
func (r UsersAPIAdminRealmsRealmUsersGetRequest) IdpAlias(idpAlias string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.idpAlias = &idpAlias
	return r
}

// The userId at an Identity Provider linked to the user
func (r UsersAPIAdminRealmsRealmUsersGetRequest) IdpUserId(idpUserId string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.idpUserId = &idpUserId
	return r
}

// A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true
func (r UsersAPIAdminRealmsRealmUsersGetRequest) LastName(lastName string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.lastName = &lastName
	return r
}

// Maximum results size (defaults to 100)
func (r UsersAPIAdminRealmsRealmUsersGetRequest) Max(max int32) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.max = &max
	return r
}

// A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39;
func (r UsersAPIAdminRealmsRealmUsersGetRequest) Q(q string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.q = &q
	return r
}

// A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search.
func (r UsersAPIAdminRealmsRealmUsersGetRequest) Search(search string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.search = &search
	return r
}

// A String contained in username, or the complete username, if param \&quot;exact\&quot; is true
func (r UsersAPIAdminRealmsRealmUsersGetRequest) Username(username string) UsersAPIAdminRealmsRealmUsersGetRequest {
	r.username = &username
	return r
}

func (r UsersAPIAdminRealmsRealmUsersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersGetExecute(r)
}

/*
AdminRealmsRealmUsersGet Get users Returns a stream of users, filtered according to query parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return UsersAPIAdminRealmsRealmUsersGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersGet(ctx context.Context, realm string) UsersAPIAdminRealmsRealmUsersGetRequest {
	return UsersAPIAdminRealmsRealmUsersGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []UserRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersGetExecute(r UsersAPIAdminRealmsRealmUsersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.emailVerified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailVerified", r.emailVerified, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.idpAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idpAlias", r.idpAlias, "")
	}
	if r.idpUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idpUserId", r.idpUserId, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersPostRequest struct {
	ctx                context.Context
	ApiService         *UsersAPIService
	realm              string
	userRepresentation *UserRepresentation
}

func (r UsersAPIAdminRealmsRealmUsersPostRequest) UserRepresentation(userRepresentation UserRepresentation) UsersAPIAdminRealmsRealmUsersPostRequest {
	r.userRepresentation = &userRepresentation
	return r
}

func (r UsersAPIAdminRealmsRealmUsersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersPostExecute(r)
}

/*
AdminRealmsRealmUsersPost Create a new user Username must be unique.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return UsersAPIAdminRealmsRealmUsersPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersPost(ctx context.Context, realm string) UsersAPIAdminRealmsRealmUsersPostRequest {
	return UsersAPIAdminRealmsRealmUsersPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersPostExecute(r UsersAPIAdminRealmsRealmUsersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersProfileGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
}

func (r UsersAPIAdminRealmsRealmUsersProfileGetRequest) Execute() (*UPConfig, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersProfileGetExecute(r)
}

/*
AdminRealmsRealmUsersProfileGet Method for AdminRealmsRealmUsersProfileGet

Get the configuration for the user profile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return UsersAPIAdminRealmsRealmUsersProfileGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersProfileGet(ctx context.Context, realm string) UsersAPIAdminRealmsRealmUsersProfileGetRequest {
	return UsersAPIAdminRealmsRealmUsersProfileGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return UPConfig
func (a *UsersAPIService) AdminRealmsRealmUsersProfileGetExecute(r UsersAPIAdminRealmsRealmUsersProfileGetRequest) (*UPConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UPConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersProfileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersProfileMetadataGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
}

func (r UsersAPIAdminRealmsRealmUsersProfileMetadataGetRequest) Execute() (*UserProfileMetadata, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersProfileMetadataGetExecute(r)
}

/*
AdminRealmsRealmUsersProfileMetadataGet Method for AdminRealmsRealmUsersProfileMetadataGet

Get the UserProfileMetadata from the configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return UsersAPIAdminRealmsRealmUsersProfileMetadataGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersProfileMetadataGet(ctx context.Context, realm string) UsersAPIAdminRealmsRealmUsersProfileMetadataGetRequest {
	return UsersAPIAdminRealmsRealmUsersProfileMetadataGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return UserProfileMetadata
func (a *UsersAPIService) AdminRealmsRealmUsersProfileMetadataGetExecute(r UsersAPIAdminRealmsRealmUsersProfileMetadataGetRequest) (*UserProfileMetadata, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserProfileMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersProfileMetadataGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/profile/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersProfilePutRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	uPConfig   *UPConfig
}

func (r UsersAPIAdminRealmsRealmUsersProfilePutRequest) UPConfig(uPConfig UPConfig) UsersAPIAdminRealmsRealmUsersProfilePutRequest {
	r.uPConfig = &uPConfig
	return r
}

func (r UsersAPIAdminRealmsRealmUsersProfilePutRequest) Execute() (*UPConfig, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersProfilePutExecute(r)
}

/*
AdminRealmsRealmUsersProfilePut Method for AdminRealmsRealmUsersProfilePut

Set the configuration for the user profile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return UsersAPIAdminRealmsRealmUsersProfilePutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersProfilePut(ctx context.Context, realm string) UsersAPIAdminRealmsRealmUsersProfilePutRequest {
	return UsersAPIAdminRealmsRealmUsersProfilePutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return UPConfig
func (a *UsersAPIService) AdminRealmsRealmUsersProfilePutExecute(r UsersAPIAdminRealmsRealmUsersProfilePutRequest) (*UPConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UPConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersProfilePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uPConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet Return credential types, which are provided by the user storage where user is stored.

Returned values can contain for example "password", "otp" etc. This will always return empty list for "local" users, which are not backed by any user storage

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []string
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/configured-user-storage-credential-types"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
	client     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdConsentsClientDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdConsentsClientDelete Revoke consent and offline tokens for particular client from user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param client Client id
	@return UsersAPIAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsClientDelete(ctx context.Context, realm string, userId string, client string) UsersAPIAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
		client:     client,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsClientDeleteExecute(r UsersAPIAdminRealmsRealmUsersUserIdConsentsClientDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdConsentsClientDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/consents/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdConsentsGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdConsentsGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdConsentsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdConsentsGet Get consents granted by the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdConsentsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdConsentsGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdConsentsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdConsentsGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdConsentsGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdConsentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/consents"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	realm        string
	userId       string
	credentialId string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdDelete Remove a credential for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param credentialId
	@return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdDelete(ctx context.Context, realm string, userId string, credentialId string) UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		realm:        realm,
		userId:       userId,
		credentialId: credentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteExecute(r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest struct {
	ctx                     context.Context
	ApiService              *UsersAPIService
	realm                   string
	userId                  string
	credentialId            string
	newPreviousCredentialId string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost Move a credential to a position behind another credential

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param credentialId The credential to move
	@param newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
	@return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(ctx context.Context, realm string, userId string, credentialId string, newPreviousCredentialId string) UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest{
		ApiService:              a,
		ctx:                     ctx,
		realm:                   realm,
		userId:                  userId,
		credentialId:            credentialId,
		newPreviousCredentialId: newPreviousCredentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostExecute(r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"newPreviousCredentialId"+"}", url.PathEscape(parameterValueToString(r.newPreviousCredentialId, "newPreviousCredentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	realm        string
	userId       string
	credentialId string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost Move a credential to a first position in the credentials list of the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param credentialId The credential to move
	@return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost(ctx context.Context, realm string, userId string, credentialId string) UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest{
		ApiService:   a,
		ctx:          ctx,
		realm:        realm,
		userId:       userId,
		credentialId: credentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostExecute(r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveToFirst"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	realm        string
	userId       string
	credentialId string
	body         *string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest) Body(body string) UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest {
	r.body = &body
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut Update a credential label for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param credentialId
	@return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut(ctx context.Context, realm string, userId string, credentialId string) UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest{
		ApiService:   a,
		ctx:          ctx,
		realm:        realm,
		userId:       userId,
		credentialId: credentialId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/userLabel"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", url.PathEscape(parameterValueToString(r.credentialId, "credentialId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdCredentialsGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdCredentialsGetRequest) Execute() ([]CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdCredentialsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdCredentialsGet Method for AdminRealmsRealmUsersUserIdCredentialsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdCredentialsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdCredentialsGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdCredentialsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []CredentialRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdCredentialsGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdCredentialsGetRequest) ([]CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdCredentialsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdDeleteRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdDelete Delete the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDelete(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdDeleteRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDeleteExecute(r UsersAPIAdminRealmsRealmUsersUserIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	realm       string
	userId      string
	requestBody *[]string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest) RequestBody(requestBody []string) UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdDisableCredentialTypesPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdDisableCredentialTypesPut Disable all credentials for a user of a specific type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDisableCredentialTypesPut(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdDisableCredentialTypesPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdDisableCredentialTypesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/disable-credential-types"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	realm       string
	userId      string
	clientId    *string
	lifespan    *int32
	redirectUri *string
	requestBody *[]string
}

// Client id
func (r UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) ClientId(clientId string) UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.clientId = &clientId
	return r
}

// Number of seconds after which the generated token expires
func (r UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) Lifespan(lifespan int32) UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.lifespan = &lifespan
	return r
}

// Redirect uri
func (r UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) RedirectUri(redirectUri string) UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.redirectUri = &redirectUri
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) RequestBody(requestBody []string) UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdExecuteActionsEmailPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdExecuteActionsEmailPut Send an email to the user with a link they can click to execute particular actions.

An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdExecuteActionsEmailPut(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdExecuteActionsEmailPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdExecuteActionsEmailPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/execute-actions-email"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "")
	}
	if r.lifespan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lifespan", r.lifespan, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redirect_uri", r.redirectUri, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest) Execute() ([]FederatedIdentityRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdFederatedIdentityGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdFederatedIdentityGet Get social logins associated with the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []FederatedIdentityRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityGetRequest) ([]FederatedIdentityRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FederatedIdentityRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdFederatedIdentityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/federated-identity"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
	provider   string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdFederatedIdentityProviderDelete Remove a social login provider from user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param provider Social login provider id
	@return UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderDelete(ctx context.Context, realm string, userId string, provider string) UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
		provider:   provider,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteExecute(r UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"provider"+"}", url.PathEscape(parameterValueToString(r.provider, "provider")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
	provider   string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdFederatedIdentityProviderPost Add a social login provider to the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param provider Social login provider id
	@return UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderPost(ctx context.Context, realm string, userId string, provider string) UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
		provider:   provider,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdFederatedIdentityProviderPostExecute(r UsersAPIAdminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdFederatedIdentityProviderPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"provider"+"}", url.PathEscape(parameterValueToString(r.provider, "provider")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdGetRequest struct {
	ctx                 context.Context
	ApiService          *UsersAPIService
	realm               string
	userId              string
	userProfileMetadata *bool
}

// Indicates if the user profile metadata should be added to the response
func (r UsersAPIAdminRealmsRealmUsersUserIdGetRequest) UserProfileMetadata(userProfileMetadata bool) UsersAPIAdminRealmsRealmUsersUserIdGetRequest {
	r.userProfileMetadata = &userProfileMetadata
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGetRequest) Execute() (*UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGet Get representation of the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return UserRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdGetRequest) (*UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userProfileMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userProfileMetadata", r.userProfileMetadata, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
	search     *string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest) Search(search string) UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest {
	r.search = &search
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsCountGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsCountGet Method for AdminRealmsRealmUsersUserIdGroupsCountGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsCountGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return map[string]int64
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsCountGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdGroupsCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest struct {
	ctx                 context.Context
	ApiService          *UsersAPIService
	realm               string
	userId              string
	briefRepresentation *bool
	first               *int32
	max                 *int32
	search              *string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest) BriefRepresentation(briefRepresentation bool) UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest) First(first int32) UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.first = &first
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest) Max(max int32) UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.max = &max
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest) Search(search string) UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest {
	r.search = &search
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsGet Method for AdminRealmsRealmUsersUserIdGroupsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []GroupRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
	groupId    string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsGroupIdDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsGroupIdDelete Method for AdminRealmsRealmUsersUserIdGroupsGroupIdDelete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param groupId
	@return UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdDelete(ctx context.Context, realm string, userId string, groupId string) UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
		groupId:    groupId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdDeleteExecute(r UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
	groupId    string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdGroupsGroupIdPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdGroupsGroupIdPut Method for AdminRealmsRealmUsersUserIdGroupsGroupIdPut

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param groupId
	@return UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdPut(ctx context.Context, realm string, userId string, groupId string) UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
		groupId:    groupId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdGroupsGroupIdPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdGroupsGroupIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdGroupsGroupIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdImpersonationPostRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdImpersonationPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdImpersonationPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdImpersonationPost Impersonate the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdImpersonationPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdImpersonationPost(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdImpersonationPostRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdImpersonationPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdImpersonationPostExecute(r UsersAPIAdminRealmsRealmUsersUserIdImpersonationPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdImpersonationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/impersonation"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdLogoutPostRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdLogoutPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdLogoutPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdLogoutPost Remove all user sessions associated with the user Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdLogoutPostRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdLogoutPost(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdLogoutPostRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdLogoutPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdLogoutPostExecute(r UsersAPIAdminRealmsRealmUsersUserIdLogoutPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdLogoutPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/logout"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
	clientUuid string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet Get offline sessions associated with the user and client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@param clientUuid
	@return UsersAPIAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet(ctx context.Context, realm string, userId string, clientUuid string) UsersAPIAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//
//	@return []UserSessionRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/offline-sessions/{clientUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientUuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdPutRequest struct {
	ctx                context.Context
	ApiService         *UsersAPIService
	realm              string
	userId             string
	userRepresentation *UserRepresentation
}

func (r UsersAPIAdminRealmsRealmUsersUserIdPutRequest) UserRepresentation(userRepresentation UserRepresentation) UsersAPIAdminRealmsRealmUsersUserIdPutRequest {
	r.userRepresentation = &userRepresentation
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdPut Update the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdPut(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	realm       string
	userId      string
	clientId    *string
	redirectUri *string
}

// client id
func (r UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) ClientId(clientId string) UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest {
	r.clientId = &clientId
	return r
}

// redirect uri
func (r UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) RedirectUri(redirectUri string) UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest {
	r.redirectUri = &redirectUri
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdResetPasswordEmailPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdResetPasswordEmailPut Send an email to the user with a link they can click to reset their password.

The redirectUri and clientId parameters are optional. The default for the redirect is the account client. This endpoint has been deprecated.  Please use the execute-actions-email passing a list with UPDATE_PASSWORD within it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest

Deprecated
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordEmailPut(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
// Deprecated
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordEmailPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdResetPasswordEmailPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdResetPasswordEmailPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/reset-password-email"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redirect_uri", r.redirectUri, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest struct {
	ctx                      context.Context
	ApiService               *UsersAPIService
	realm                    string
	userId                   string
	credentialRepresentation *CredentialRepresentation
}

func (r UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest) CredentialRepresentation(credentialRepresentation CredentialRepresentation) UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest {
	r.credentialRepresentation = &credentialRepresentation
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdResetPasswordPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdResetPasswordPut Set up a new password for the user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordPut(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdResetPasswordPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdResetPasswordPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdResetPasswordPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/reset-password"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.credentialRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	realm       string
	userId      string
	clientId    *string
	lifespan    *int32
	redirectUri *string
}

// Client id
func (r UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) ClientId(clientId string) UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	r.clientId = &clientId
	return r
}

// Number of seconds after which the generated token expires
func (r UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) Lifespan(lifespan int32) UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	r.lifespan = &lifespan
	return r
}

// Redirect uri
func (r UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) RedirectUri(redirectUri string) UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	r.redirectUri = &redirectUri
	return r
}

func (r UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdSendVerifyEmailPutExecute(r)
}

/*
AdminRealmsRealmUsersUserIdSendVerifyEmailPut Send an email-verification email to the user An email contains a link the user can click to verify their email address.

The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSendVerifyEmailPut(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSendVerifyEmailPutExecute(r UsersAPIAdminRealmsRealmUsersUserIdSendVerifyEmailPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdSendVerifyEmailPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/send-verify-email"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "")
	}
	if r.lifespan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lifespan", r.lifespan, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redirect_uri", r.redirectUri, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAdminRealmsRealmUsersUserIdSessionsGetRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	realm      string
	userId     string
}

func (r UsersAPIAdminRealmsRealmUsersUserIdSessionsGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdSessionsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdSessionsGet Get sessions associated with the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param userId
	@return UsersAPIAdminRealmsRealmUsersUserIdSessionsGetRequest
*/
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSessionsGet(ctx context.Context, realm string, userId string) UsersAPIAdminRealmsRealmUsersUserIdSessionsGetRequest {
	return UsersAPIAdminRealmsRealmUsersUserIdSessionsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []UserSessionRepresentation
func (a *UsersAPIService) AdminRealmsRealmUsersUserIdSessionsGetExecute(r UsersAPIAdminRealmsRealmUsersUserIdSessionsGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AdminRealmsRealmUsersUserIdSessionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
