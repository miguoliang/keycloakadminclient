/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// RealmsAdminAPIService RealmsAdminAPI service
type RealmsAdminAPIService service

type RealmsAdminAPIAdminRealmsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	briefRepresentation *bool
}

func (r RealmsAdminAPIAdminRealmsGetRequest) BriefRepresentation(briefRepresentation bool) RealmsAdminAPIAdminRealmsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r RealmsAdminAPIAdminRealmsGetRequest) Execute() ([]RealmRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsGetExecute(r)
}

/*
AdminRealmsGet Get accessible realms Returns a list of accessible realms. The list is filtered based on what realms the caller is allowed to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealmsAdminAPIAdminRealmsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsGet(ctx context.Context) RealmsAdminAPIAdminRealmsGetRequest {
	return RealmsAdminAPIAdminRealmsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RealmRepresentation
func (a *RealmsAdminAPIService) AdminRealmsGetExecute(r RealmsAdminAPIAdminRealmsGetRequest) ([]RealmRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RealmRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = false
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	body *os.File
}

func (r RealmsAdminAPIAdminRealmsPostRequest) Body(body *os.File) RealmsAdminAPIAdminRealmsPostRequest {
	r.body = body
	return r
}

func (r RealmsAdminAPIAdminRealmsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsPostExecute(r)
}

/*
AdminRealmsPost Import a realm. Imports a realm from a full representation of that realm.

Realm name must be unique.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealmsAdminAPIAdminRealmsPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsPost(ctx context.Context) RealmsAdminAPIAdminRealmsPostRequest {
	return RealmsAdminAPIAdminRealmsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsPostExecute(r RealmsAdminAPIAdminRealmsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmAdminEventsDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAdminEventsDeleteExecute(r)
}

/*
AdminRealmsRealmAdminEventsDelete Delete all admin events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmAdminEventsDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsDelete(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmAdminEventsDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmAdminEventsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsDeleteExecute(r RealmsAdminAPIAdminRealmsRealmAdminEventsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmAdminEventsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/admin-events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	authClient *string
	authIpAddress *string
	authRealm *string
	authUser *string
	dateFrom *string
	dateTo *string
	first *int32
	max *int32
	operationTypes *[]string
	resourcePath *string
	resourceTypes *[]string
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) AuthClient(authClient string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.authClient = &authClient
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) AuthIpAddress(authIpAddress string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.authIpAddress = &authIpAddress
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) AuthRealm(authRealm string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.authRealm = &authRealm
	return r
}

// user id
func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) AuthUser(authUser string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.authUser = &authUser
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) DateFrom(dateFrom string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) DateTo(dateTo string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.dateTo = &dateTo
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) First(first int32) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) Max(max int32) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.max = &max
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) OperationTypes(operationTypes []string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.operationTypes = &operationTypes
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) ResourcePath(resourcePath string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.resourcePath = &resourcePath
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) ResourceTypes(resourceTypes []string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	r.resourceTypes = &resourceTypes
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) Execute() ([]AdminEventRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAdminEventsGetExecute(r)
}

/*
AdminRealmsRealmAdminEventsGet Get admin events Returns all admin events, or filters events based on URL query parameters listed here

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest {
	return RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []AdminEventRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsGetExecute(r RealmsAdminAPIAdminRealmsRealmAdminEventsGetRequest) ([]AdminEventRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AdminEventRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmAdminEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/admin-events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authClient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authClient", r.authClient, "")
	}
	if r.authIpAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authIpAddress", r.authIpAddress, "")
	}
	if r.authRealm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authRealm", r.authRealm, "")
	}
	if r.authUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authUser", r.authUser, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateFrom", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateTo", r.dateTo, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.operationTypes != nil {
		t := *r.operationTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "operationTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "operationTypes", t, "multi")
		}
	}
	if r.resourcePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourcePath", r.resourcePath, "")
	}
	if r.resourceTypes != nil {
		t := *r.resourceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "resourceTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "resourceTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	body *string
}

func (r RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest) Body(body string) RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest {
	r.body = &body
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest) Execute() (*ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientDescriptionConverterPostExecute(r)
}

/*
AdminRealmsRealmClientDescriptionConverterPost Base path for importing clients under this realm.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientDescriptionConverterPost(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest {
	return RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ClientRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmClientDescriptionConverterPostExecute(r RealmsAdminAPIAdminRealmsRealmClientDescriptionConverterPostRequest) (*ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientDescriptionConverterPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-description-converter"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesGetRequest) Execute() (*ClientPoliciesRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesPoliciesGetExecute(r)
}

/*
AdminRealmsRealmClientPoliciesPoliciesGet Method for AdminRealmsRealmClientPoliciesPoliciesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesGetRequest {
	return RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ClientPoliciesRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesGetExecute(r RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesGetRequest) (*ClientPoliciesRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientPoliciesRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesPoliciesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientPoliciesRepresentation *ClientPoliciesRepresentation
}

func (r RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest) ClientPoliciesRepresentation(clientPoliciesRepresentation ClientPoliciesRepresentation) RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest {
	r.clientPoliciesRepresentation = &clientPoliciesRepresentation
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesPoliciesPutExecute(r)
}

/*
AdminRealmsRealmClientPoliciesPoliciesPut Method for AdminRealmsRealmClientPoliciesPoliciesPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesPut(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest {
	return RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesPutExecute(r RealmsAdminAPIAdminRealmsRealmClientPoliciesPoliciesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesPoliciesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientPoliciesRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	includeGlobalProfiles *bool
}

func (r RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest) IncludeGlobalProfiles(includeGlobalProfiles bool) RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest {
	r.includeGlobalProfiles = &includeGlobalProfiles
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest) Execute() (*ClientProfilesRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesProfilesGetExecute(r)
}

/*
AdminRealmsRealmClientPoliciesProfilesGet Method for AdminRealmsRealmClientPoliciesProfilesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest {
	return RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ClientProfilesRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesGetExecute(r RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesGetRequest) (*ClientProfilesRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientProfilesRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesProfilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeGlobalProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-global-profiles", r.includeGlobalProfiles, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientProfilesRepresentation *ClientProfilesRepresentation
}

func (r RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest) ClientProfilesRepresentation(clientProfilesRepresentation ClientProfilesRepresentation) RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest {
	r.clientProfilesRepresentation = &clientProfilesRepresentation
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesProfilesPutExecute(r)
}

/*
AdminRealmsRealmClientPoliciesProfilesPut Method for AdminRealmsRealmClientPoliciesProfilesPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesPut(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest {
	return RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesPutExecute(r RealmsAdminAPIAdminRealmsRealmClientPoliciesProfilesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesProfilesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientProfilesRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmClientSessionStatsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmClientSessionStatsGetRequest) Execute() ([]map[string]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientSessionStatsGetExecute(r)
}

/*
AdminRealmsRealmClientSessionStatsGet Get client session stats Returns a JSON map.

The key is the client id, the value is the number of sessions that currently are active with that client. Only clients that actually have a session associated with them will be in this map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmClientSessionStatsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientSessionStatsGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmClientSessionStatsGetRequest {
	return RealmsAdminAPIAdminRealmsRealmClientSessionStatsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []map[string]string
func (a *RealmsAdminAPIService) AdminRealmsRealmClientSessionStatsGetExecute(r RealmsAdminAPIAdminRealmsRealmClientSessionStatsGetRequest) ([]map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientSessionStatsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-session-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmCredentialRegistratorsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmCredentialRegistratorsGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmCredentialRegistratorsGetExecute(r)
}

/*
AdminRealmsRealmCredentialRegistratorsGet Method for AdminRealmsRealmCredentialRegistratorsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmCredentialRegistratorsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmCredentialRegistratorsGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmCredentialRegistratorsGetRequest {
	return RealmsAdminAPIAdminRealmsRealmCredentialRegistratorsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []string
func (a *RealmsAdminAPIService) AdminRealmsRealmCredentialRegistratorsGetExecute(r RealmsAdminAPIAdminRealmsRealmCredentialRegistratorsGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmCredentialRegistratorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/credential-registrators"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete Method for AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientScopeId string) RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteExecute(r RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut Method for AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut(ctx context.Context, realm string, clientScopeId string) RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutExecute(r RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultDefaultClientScopesGetExecute(r)
}

/*
AdminRealmsRealmDefaultDefaultClientScopesGet Get realm default client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesGetRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesGetExecute(r RealmsAdminAPIAdminRealmsRealmDefaultDefaultClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultDefaultClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-default-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultGroupsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultGroupsGetExecute(r)
}

/*
AdminRealmsRealmDefaultGroupsGet Get group hierarchy.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmDefaultGroupsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmDefaultGroupsGetRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGetExecute(r RealmsAdminAPIAdminRealmsRealmDefaultGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	groupId string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultGroupsGroupIdDeleteExecute(r)
}

/*
AdminRealmsRealmDefaultGroupsGroupIdDelete Method for AdminRealmsRealmDefaultGroupsGroupIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdDelete(ctx context.Context, realm string, groupId string) RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdDeleteExecute(r RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultGroupsGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	groupId string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultGroupsGroupIdPutExecute(r)
}

/*
AdminRealmsRealmDefaultGroupsGroupIdPut Method for AdminRealmsRealmDefaultGroupsGroupIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdPut(ctx context.Context, realm string, groupId string) RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdPutRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdPutExecute(r RealmsAdminAPIAdminRealmsRealmDefaultGroupsGroupIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultGroupsGroupIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete Method for AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientScopeId string) RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteExecute(r RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut Method for AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut(ctx context.Context, realm string, clientScopeId string) RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutExecute(r RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultOptionalClientScopesGetExecute(r)
}

/*
AdminRealmsRealmDefaultOptionalClientScopesGet Get realm optional client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesGetRequest {
	return RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesGetExecute(r RealmsAdminAPIAdminRealmsRealmDefaultOptionalClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultOptionalClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-optional-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmDelete Delete the realm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDelete(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDeleteExecute(r RealmsAdminAPIAdminRealmsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmEventsConfigGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmEventsConfigGetRequest) Execute() (*RealmEventsConfigRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsConfigGetExecute(r)
}

/*
AdminRealmsRealmEventsConfigGet Get the events provider configuration Returns JSON object with events provider configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmEventsConfigGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmEventsConfigGetRequest {
	return RealmsAdminAPIAdminRealmsRealmEventsConfigGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return RealmEventsConfigRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigGetExecute(r RealmsAdminAPIAdminRealmsRealmEventsConfigGetRequest) (*RealmEventsConfigRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RealmEventsConfigRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	realmEventsConfigRepresentation *RealmEventsConfigRepresentation
}

func (r RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest) RealmEventsConfigRepresentation(realmEventsConfigRepresentation RealmEventsConfigRepresentation) RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest {
	r.realmEventsConfigRepresentation = &realmEventsConfigRepresentation
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsConfigPutExecute(r)
}

/*
AdminRealmsRealmEventsConfigPut Method for AdminRealmsRealmEventsConfigPut

Update the events provider Change the events provider and/or its configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigPut(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest {
	return RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigPutExecute(r RealmsAdminAPIAdminRealmsRealmEventsConfigPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsConfigPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.realmEventsConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmEventsDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmEventsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsDeleteExecute(r)
}

/*
AdminRealmsRealmEventsDelete Delete all events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmEventsDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsDelete(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmEventsDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmEventsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsDeleteExecute(r RealmsAdminAPIAdminRealmsRealmEventsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmEventsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	client *string
	dateFrom *string
	dateTo *string
	first *int32
	ipAddress *string
	max *int32
	type_ *[]string
	user *string
}

// App or oauth client name
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) Client(client string) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.client = &client
	return r
}

// From date
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) DateFrom(dateFrom string) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// To date
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) DateTo(dateTo string) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.dateTo = &dateTo
	return r
}

// Paging offset
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) First(first int32) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.first = &first
	return r
}

// IP Address
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) IpAddress(ipAddress string) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.ipAddress = &ipAddress
	return r
}

// Maximum results size (defaults to 100)
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) Max(max int32) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.max = &max
	return r
}

// The types of events to return
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) Type_(type_ []string) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.type_ = &type_
	return r
}

// User id
func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) User(user string) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	r.user = &user
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) Execute() ([]EventRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsGetExecute(r)
}

/*
AdminRealmsRealmEventsGet Get events Returns all events, or filters them based on URL query parameters listed here

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmEventsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmEventsGetRequest {
	return RealmsAdminAPIAdminRealmsRealmEventsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []EventRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsGetExecute(r RealmsAdminAPIAdminRealmsRealmEventsGetRequest) ([]EventRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EventRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.client != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client", r.client, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateFrom", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateTo", r.dateTo, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipAddress", r.ipAddress, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmGetRequest) Execute() (*RealmRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGetExecute(r)
}

/*
AdminRealmsRealmGet Get the top-level representation of the realm It will not include nested information like User and Client representations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmGetRequest {
	return RealmsAdminAPIAdminRealmsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return RealmRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmGetExecute(r RealmsAdminAPIAdminRealmsRealmGetRequest) (*RealmRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RealmRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmGroupByPathPathGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	path []PathSegment
}

func (r RealmsAdminAPIAdminRealmsRealmGroupByPathPathGetRequest) Execute() (*GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupByPathPathGetExecute(r)
}

/*
AdminRealmsRealmGroupByPathPathGet Method for AdminRealmsRealmGroupByPathPathGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param path
 @return RealmsAdminAPIAdminRealmsRealmGroupByPathPathGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmGroupByPathPathGet(ctx context.Context, realm string, path []PathSegment) RealmsAdminAPIAdminRealmsRealmGroupByPathPathGetRequest {
	return RealmsAdminAPIAdminRealmsRealmGroupByPathPathGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		path: path,
	}
}

// Execute executes the request
//  @return GroupRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmGroupByPathPathGetExecute(r RealmsAdminAPIAdminRealmsRealmGroupByPathPathGetRequest) (*GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmGroupByPathPathGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/group-by-path/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLocalizationGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationGetExecute(r)
}

/*
AdminRealmsRealmLocalizationGet Method for AdminRealmsRealmLocalizationGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmLocalizationGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmLocalizationGetRequest {
	return RealmsAdminAPIAdminRealmsRealmLocalizationGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []string
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationGetExecute(r RealmsAdminAPIAdminRealmsRealmLocalizationGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLocalizationLocaleDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	locale string
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleDeleteExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleDelete Method for AdminRealmsRealmLocalizationLocaleDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param locale
 @return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleDelete(ctx context.Context, realm string, locale string) RealmsAdminAPIAdminRealmsRealmLocalizationLocaleDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleDeleteExecute(r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLocalizationLocaleGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	locale string
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleGetRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleGetExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleGet Method for AdminRealmsRealmLocalizationLocaleGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param locale
 @return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleGet(ctx context.Context, realm string, locale string) RealmsAdminAPIAdminRealmsRealmLocalizationLocaleGetRequest {
	return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		locale: locale,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleGetExecute(r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleGetRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	key string
	locale string
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleKeyDeleteExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleKeyDelete Method for AdminRealmsRealmLocalizationLocaleKeyDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param key
 @param locale
 @return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyDelete(ctx context.Context, realm string, key string, locale string) RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		key: key,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyDeleteExecute(r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleKeyDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	key string
	locale string
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleKeyGetExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleKeyGet Method for AdminRealmsRealmLocalizationLocaleKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param key
 @param locale
 @return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyGet(ctx context.Context, realm string, key string, locale string) RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyGetRequest {
	return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		key: key,
		locale: locale,
	}
}

// Execute executes the request
//  @return string
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyGetExecute(r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	key string
	locale string
	body *string
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest) Body(body string) RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest {
	r.body = &body
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleKeyPutExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleKeyPut Method for AdminRealmsRealmLocalizationLocaleKeyPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param key
 @param locale
 @return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyPut(ctx context.Context, realm string, key string, locale string) RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest {
	return RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		key: key,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyPutExecute(r RealmsAdminAPIAdminRealmsRealmLocalizationLocaleKeyPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleKeyPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	locale string
	requestBody *map[string]string
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest) RequestBody(requestBody map[string]string) RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest {
	r.requestBody = &requestBody
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocalePostExecute(r)
}

/*
AdminRealmsRealmLocalizationLocalePost Import localization from uploaded JSON file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param locale
 @return RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocalePost(ctx context.Context, realm string, locale string) RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest {
	return RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocalePostExecute(r RealmsAdminAPIAdminRealmsRealmLocalizationLocalePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocalePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmLogoutAllPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmLogoutAllPostRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLogoutAllPostExecute(r)
}

/*
AdminRealmsRealmLogoutAllPost Removes all user sessions.

Any client that has an admin url will also be told to invalidate any sessions they have.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmLogoutAllPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLogoutAllPost(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmLogoutAllPostRequest {
	return RealmsAdminAPIAdminRealmsRealmLogoutAllPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *RealmsAdminAPIService) AdminRealmsRealmLogoutAllPostExecute(r RealmsAdminAPIAdminRealmsRealmLogoutAllPostRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLogoutAllPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/logout-all"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	exportClients *bool
	exportGroupsAndRoles *bool
}

func (r RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest) ExportClients(exportClients bool) RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest {
	r.exportClients = &exportClients
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest) ExportGroupsAndRoles(exportGroupsAndRoles bool) RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest {
	r.exportGroupsAndRoles = &exportGroupsAndRoles
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmPartialExportPostExecute(r)
}

/*
AdminRealmsRealmPartialExportPost Partial export of existing realm into a JSON file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialExportPost(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest {
	return RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialExportPostExecute(r RealmsAdminAPIAdminRealmsRealmPartialExportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPartialExportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/partial-export"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exportClients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportClients", r.exportClients, "")
	}
	if r.exportGroupsAndRoles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportGroupsAndRoles", r.exportGroupsAndRoles, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	body *os.File
}

func (r RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest) Body(body *os.File) RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest {
	r.body = body
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmPartialImportPostExecute(r)
}

/*
AdminRealmsRealmPartialImportPost Partial import from a JSON file to an existing realm.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialImportPost(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest {
	return RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialImportPostExecute(r RealmsAdminAPIAdminRealmsRealmPartialImportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPartialImportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/partialImport"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmPushRevocationPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmPushRevocationPostRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmPushRevocationPostExecute(r)
}

/*
AdminRealmsRealmPushRevocationPost Push the realm's revocation policy to any client that has an admin url associated with it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmPushRevocationPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPushRevocationPost(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmPushRevocationPostRequest {
	return RealmsAdminAPIAdminRealmsRealmPushRevocationPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *RealmsAdminAPIService) AdminRealmsRealmPushRevocationPostExecute(r RealmsAdminAPIAdminRealmsRealmPushRevocationPostRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPushRevocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/push-revocation"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	realmRepresentation *RealmRepresentation
}

func (r RealmsAdminAPIAdminRealmsRealmPutRequest) RealmRepresentation(realmRepresentation RealmRepresentation) RealmsAdminAPIAdminRealmsRealmPutRequest {
	r.realmRepresentation = &realmRepresentation
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmPutExecute(r)
}

/*
AdminRealmsRealmPut Update the top-level information of the realm Any user, roles or client information in the representation will be ignored.

This will only update top-level attributes of the realm.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPut(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmPutRequest {
	return RealmsAdminAPIAdminRealmsRealmPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmPutExecute(r RealmsAdminAPIAdminRealmsRealmPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.realmRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	session string
	isOffline *bool
}

func (r RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest) IsOffline(isOffline bool) RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest {
	r.isOffline = &isOffline
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmSessionsSessionDeleteExecute(r)
}

/*
AdminRealmsRealmSessionsSessionDelete Remove a specific user session.

Any client that has an admin url will also be told to invalidate this particular session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param session
 @return RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmSessionsSessionDelete(ctx context.Context, realm string, session string) RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest {
	return RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		session: session,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmSessionsSessionDeleteExecute(r RealmsAdminAPIAdminRealmsRealmSessionsSessionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmSessionsSessionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/sessions/{session}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session"+"}", url.PathEscape(parameterValueToString(r.session, "session")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isOffline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isOffline", r.isOffline, "")
	} else {
		var defaultValue bool = false
		r.isOffline = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmUsersManagementPermissionsGet Method for AdminRealmsRealmUsersManagementPermissionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsGet(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsGetRequest {
	return RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsGetExecute(r RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmUsersManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users-management-permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	managementPermissionReference *ManagementPermissionReference
}

func (r RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmUsersManagementPermissionsPut Method for AdminRealmsRealmUsersManagementPermissionsPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsPut(ctx context.Context, realm string) RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest {
	return RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsPutExecute(r RealmsAdminAPIAdminRealmsRealmUsersManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmUsersManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users-management-permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
