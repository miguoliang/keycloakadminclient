/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RoleMapperAPIService RoleMapperAPI service
type RoleMapperAPIService service

type RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsGet Get role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsGet(ctx context.Context, realm string, groupId string) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest {
	return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MappingsRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsGetExecute(r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGet Get realm-level roles that can be mapped

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGet(ctx context.Context, realm string, groupId string) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest {
	return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetExecute(r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGet Get effective realm-level role mappings This will recurse all composite roles to get the result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGet(ctx context.Context, realm string, groupId string) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest {
	return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetExecute(r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
	roleRepresentation *[]RoleRepresentation
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDelete Delete realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDelete(ctx context.Context, realm string, groupId string) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest {
	return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteExecute(r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGet Get realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGet(ctx context.Context, realm string, groupId string) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest {
	return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetExecute(r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
	roleRepresentation *[]RoleRepresentation
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPost Add realm-level role mappings to the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPost(ctx context.Context, realm string, groupId string) RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest {
	return RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostExecute(r RoleMapperAPIAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsGet Get role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsGet(ctx context.Context, realm string, userId string) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsGetRequest {
	return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return MappingsRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsGetExecute(r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGet Get realm-level roles that can be mapped

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGet(ctx context.Context, realm string, userId string) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest {
	return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetExecute(r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGet Get effective realm-level role mappings This will recurse all composite roles to get the result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGet(ctx context.Context, realm string, userId string) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest {
	return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetExecute(r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
	roleRepresentation *[]RoleRepresentation
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmDelete Delete realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmDelete(ctx context.Context, realm string, userId string) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest {
	return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteExecute(r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmGet Get realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmGet(ctx context.Context, realm string, userId string) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest {
	return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmGetExecute(r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
	roleRepresentation *[]RoleRepresentation
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmPost Add realm-level role mappings to the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmPost(ctx context.Context, realm string, userId string) RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest {
	return RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmPostExecute(r RoleMapperAPIAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
