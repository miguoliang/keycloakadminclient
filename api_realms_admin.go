/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// RealmsAdminAPIService RealmsAdminAPI service
type RealmsAdminAPIService service

type ApiAdminRealmsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	briefRepresentation *bool
}

func (r ApiAdminRealmsGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsGetRequest) Execute() ([]RealmRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsGetExecute(r)
}

/*
AdminRealmsGet Get accessible realms Returns a list of accessible realms. The list is filtered based on what realms the caller is allowed to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminRealmsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsGet(ctx context.Context) ApiAdminRealmsGetRequest {
	return ApiAdminRealmsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RealmRepresentation
func (a *RealmsAdminAPIService) AdminRealmsGetExecute(r ApiAdminRealmsGetRequest) ([]RealmRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RealmRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = false
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	body *os.File
}

func (r ApiAdminRealmsPostRequest) Body(body *os.File) ApiAdminRealmsPostRequest {
	r.body = body
	return r
}

func (r ApiAdminRealmsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsPostExecute(r)
}

/*
AdminRealmsPost Import a realm. Imports a realm from a full representation of that realm.

Realm name must be unique.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminRealmsPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsPost(ctx context.Context) ApiAdminRealmsPostRequest {
	return ApiAdminRealmsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsPostExecute(r ApiAdminRealmsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAdminEventsDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmAdminEventsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAdminEventsDeleteExecute(r)
}

/*
AdminRealmsRealmAdminEventsDelete Delete all admin events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAdminEventsDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsDelete(ctx context.Context, realm string) ApiAdminRealmsRealmAdminEventsDeleteRequest {
	return ApiAdminRealmsRealmAdminEventsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsDeleteExecute(r ApiAdminRealmsRealmAdminEventsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmAdminEventsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/admin-events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAdminEventsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	authClient *string
	authIpAddress *string
	authRealm *string
	authUser *string
	dateFrom *string
	dateTo *string
	first *int32
	max *int32
	operationTypes *[]string
	resourcePath *string
	resourceTypes *[]string
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) AuthClient(authClient string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.authClient = &authClient
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) AuthIpAddress(authIpAddress string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.authIpAddress = &authIpAddress
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) AuthRealm(authRealm string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.authRealm = &authRealm
	return r
}

// user id
func (r ApiAdminRealmsRealmAdminEventsGetRequest) AuthUser(authUser string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.authUser = &authUser
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) DateFrom(dateFrom string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) DateTo(dateTo string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.dateTo = &dateTo
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) First(first int32) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r ApiAdminRealmsRealmAdminEventsGetRequest) Max(max int32) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) OperationTypes(operationTypes []string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.operationTypes = &operationTypes
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) ResourcePath(resourcePath string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.resourcePath = &resourcePath
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) ResourceTypes(resourceTypes []string) ApiAdminRealmsRealmAdminEventsGetRequest {
	r.resourceTypes = &resourceTypes
	return r
}

func (r ApiAdminRealmsRealmAdminEventsGetRequest) Execute() ([]AdminEventRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAdminEventsGetExecute(r)
}

/*
AdminRealmsRealmAdminEventsGet Get admin events Returns all admin events, or filters events based on URL query parameters listed here

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAdminEventsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsGet(ctx context.Context, realm string) ApiAdminRealmsRealmAdminEventsGetRequest {
	return ApiAdminRealmsRealmAdminEventsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []AdminEventRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmAdminEventsGetExecute(r ApiAdminRealmsRealmAdminEventsGetRequest) ([]AdminEventRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AdminEventRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmAdminEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/admin-events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authClient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authClient", r.authClient, "")
	}
	if r.authIpAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authIpAddress", r.authIpAddress, "")
	}
	if r.authRealm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authRealm", r.authRealm, "")
	}
	if r.authUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authUser", r.authUser, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateFrom", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateTo", r.dateTo, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.operationTypes != nil {
		t := *r.operationTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "operationTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "operationTypes", t, "multi")
		}
	}
	if r.resourcePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourcePath", r.resourcePath, "")
	}
	if r.resourceTypes != nil {
		t := *r.resourceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "resourceTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "resourceTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientDescriptionConverterPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	body *string
}

func (r ApiAdminRealmsRealmClientDescriptionConverterPostRequest) Body(body string) ApiAdminRealmsRealmClientDescriptionConverterPostRequest {
	r.body = &body
	return r
}

func (r ApiAdminRealmsRealmClientDescriptionConverterPostRequest) Execute() (*ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientDescriptionConverterPostExecute(r)
}

/*
AdminRealmsRealmClientDescriptionConverterPost Base path for importing clients under this realm.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientDescriptionConverterPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientDescriptionConverterPost(ctx context.Context, realm string) ApiAdminRealmsRealmClientDescriptionConverterPostRequest {
	return ApiAdminRealmsRealmClientDescriptionConverterPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ClientRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmClientDescriptionConverterPostExecute(r ApiAdminRealmsRealmClientDescriptionConverterPostRequest) (*ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientDescriptionConverterPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-description-converter"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientPoliciesPoliciesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmClientPoliciesPoliciesGetRequest) Execute() (*ClientPoliciesRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesPoliciesGetExecute(r)
}

/*
AdminRealmsRealmClientPoliciesPoliciesGet Method for AdminRealmsRealmClientPoliciesPoliciesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientPoliciesPoliciesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesGet(ctx context.Context, realm string) ApiAdminRealmsRealmClientPoliciesPoliciesGetRequest {
	return ApiAdminRealmsRealmClientPoliciesPoliciesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ClientPoliciesRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesGetExecute(r ApiAdminRealmsRealmClientPoliciesPoliciesGetRequest) (*ClientPoliciesRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientPoliciesRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesPoliciesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientPoliciesRepresentation *ClientPoliciesRepresentation
}

func (r ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest) ClientPoliciesRepresentation(clientPoliciesRepresentation ClientPoliciesRepresentation) ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest {
	r.clientPoliciesRepresentation = &clientPoliciesRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesPoliciesPutExecute(r)
}

/*
AdminRealmsRealmClientPoliciesPoliciesPut Method for AdminRealmsRealmClientPoliciesPoliciesPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesPut(ctx context.Context, realm string) ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest {
	return ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesPoliciesPutExecute(r ApiAdminRealmsRealmClientPoliciesPoliciesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesPoliciesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientPoliciesRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientPoliciesProfilesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	includeGlobalProfiles *bool
}

func (r ApiAdminRealmsRealmClientPoliciesProfilesGetRequest) IncludeGlobalProfiles(includeGlobalProfiles bool) ApiAdminRealmsRealmClientPoliciesProfilesGetRequest {
	r.includeGlobalProfiles = &includeGlobalProfiles
	return r
}

func (r ApiAdminRealmsRealmClientPoliciesProfilesGetRequest) Execute() (*ClientProfilesRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesProfilesGetExecute(r)
}

/*
AdminRealmsRealmClientPoliciesProfilesGet Method for AdminRealmsRealmClientPoliciesProfilesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientPoliciesProfilesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesGet(ctx context.Context, realm string) ApiAdminRealmsRealmClientPoliciesProfilesGetRequest {
	return ApiAdminRealmsRealmClientPoliciesProfilesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ClientProfilesRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesGetExecute(r ApiAdminRealmsRealmClientPoliciesProfilesGetRequest) (*ClientProfilesRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientProfilesRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesProfilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeGlobalProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-global-profiles", r.includeGlobalProfiles, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientPoliciesProfilesPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientProfilesRepresentation *ClientProfilesRepresentation
}

func (r ApiAdminRealmsRealmClientPoliciesProfilesPutRequest) ClientProfilesRepresentation(clientProfilesRepresentation ClientProfilesRepresentation) ApiAdminRealmsRealmClientPoliciesProfilesPutRequest {
	r.clientProfilesRepresentation = &clientProfilesRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientPoliciesProfilesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientPoliciesProfilesPutExecute(r)
}

/*
AdminRealmsRealmClientPoliciesProfilesPut Method for AdminRealmsRealmClientPoliciesProfilesPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientPoliciesProfilesPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesPut(ctx context.Context, realm string) ApiAdminRealmsRealmClientPoliciesProfilesPutRequest {
	return ApiAdminRealmsRealmClientPoliciesProfilesPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmClientPoliciesProfilesPutExecute(r ApiAdminRealmsRealmClientPoliciesProfilesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientPoliciesProfilesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-policies/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientProfilesRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientSessionStatsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmClientSessionStatsGetRequest) Execute() ([]map[string]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientSessionStatsGetExecute(r)
}

/*
AdminRealmsRealmClientSessionStatsGet Get client session stats Returns a JSON map.

The key is the client id, the value is the number of sessions that currently are active with that client. Only clients that actually have a session associated with them will be in this map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientSessionStatsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmClientSessionStatsGet(ctx context.Context, realm string) ApiAdminRealmsRealmClientSessionStatsGetRequest {
	return ApiAdminRealmsRealmClientSessionStatsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []map[string]string
func (a *RealmsAdminAPIService) AdminRealmsRealmClientSessionStatsGetExecute(r ApiAdminRealmsRealmClientSessionStatsGetRequest) ([]map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmClientSessionStatsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/client-session-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmCredentialRegistratorsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmCredentialRegistratorsGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmCredentialRegistratorsGetExecute(r)
}

/*
AdminRealmsRealmCredentialRegistratorsGet Method for AdminRealmsRealmCredentialRegistratorsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmCredentialRegistratorsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmCredentialRegistratorsGet(ctx context.Context, realm string) ApiAdminRealmsRealmCredentialRegistratorsGetRequest {
	return ApiAdminRealmsRealmCredentialRegistratorsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []string
func (a *RealmsAdminAPIService) AdminRealmsRealmCredentialRegistratorsGetExecute(r ApiAdminRealmsRealmCredentialRegistratorsGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmCredentialRegistratorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/credential-registrators"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete Method for AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest {
	return ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteExecute(r ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut Method for AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest {
	return ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutExecute(r ApiAdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultDefaultClientScopesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmDefaultDefaultClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultDefaultClientScopesGetExecute(r)
}

/*
AdminRealmsRealmDefaultDefaultClientScopesGet Get realm default client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmDefaultDefaultClientScopesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesGet(ctx context.Context, realm string) ApiAdminRealmsRealmDefaultDefaultClientScopesGetRequest {
	return ApiAdminRealmsRealmDefaultDefaultClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultDefaultClientScopesGetExecute(r ApiAdminRealmsRealmDefaultDefaultClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultDefaultClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-default-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultGroupsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmDefaultGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultGroupsGetExecute(r)
}

/*
AdminRealmsRealmDefaultGroupsGet Get group hierarchy.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmDefaultGroupsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGet(ctx context.Context, realm string) ApiAdminRealmsRealmDefaultGroupsGetRequest {
	return ApiAdminRealmsRealmDefaultGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGetExecute(r ApiAdminRealmsRealmDefaultGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultGroupsGroupIdDeleteExecute(r)
}

/*
AdminRealmsRealmDefaultGroupsGroupIdDelete Method for AdminRealmsRealmDefaultGroupsGroupIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdDelete(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest {
	return ApiAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdDeleteExecute(r ApiAdminRealmsRealmDefaultGroupsGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultGroupsGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultGroupsGroupIdPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmDefaultGroupsGroupIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultGroupsGroupIdPutExecute(r)
}

/*
AdminRealmsRealmDefaultGroupsGroupIdPut Method for AdminRealmsRealmDefaultGroupsGroupIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmDefaultGroupsGroupIdPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdPut(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmDefaultGroupsGroupIdPutRequest {
	return ApiAdminRealmsRealmDefaultGroupsGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultGroupsGroupIdPutExecute(r ApiAdminRealmsRealmDefaultGroupsGroupIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultGroupsGroupIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete Method for AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest {
	return ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteExecute(r ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	clientScopeId string
}

func (r ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut Method for AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut(ctx context.Context, realm string, clientScopeId string) ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest {
	return ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutExecute(r ApiAdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDefaultOptionalClientScopesGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmDefaultOptionalClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmDefaultOptionalClientScopesGetExecute(r)
}

/*
AdminRealmsRealmDefaultOptionalClientScopesGet Get realm optional client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmDefaultOptionalClientScopesGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesGet(ctx context.Context, realm string) ApiAdminRealmsRealmDefaultOptionalClientScopesGetRequest {
	return ApiAdminRealmsRealmDefaultOptionalClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmDefaultOptionalClientScopesGetExecute(r ApiAdminRealmsRealmDefaultOptionalClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDefaultOptionalClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/default-optional-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmDelete Delete the realm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmDelete(ctx context.Context, realm string) ApiAdminRealmsRealmDeleteRequest {
	return ApiAdminRealmsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmDeleteExecute(r ApiAdminRealmsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmEventsConfigGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmEventsConfigGetRequest) Execute() (*RealmEventsConfigRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsConfigGetExecute(r)
}

/*
AdminRealmsRealmEventsConfigGet Get the events provider configuration Returns JSON object with events provider configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmEventsConfigGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigGet(ctx context.Context, realm string) ApiAdminRealmsRealmEventsConfigGetRequest {
	return ApiAdminRealmsRealmEventsConfigGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return RealmEventsConfigRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigGetExecute(r ApiAdminRealmsRealmEventsConfigGetRequest) (*RealmEventsConfigRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RealmEventsConfigRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmEventsConfigPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	realmEventsConfigRepresentation *RealmEventsConfigRepresentation
}

func (r ApiAdminRealmsRealmEventsConfigPutRequest) RealmEventsConfigRepresentation(realmEventsConfigRepresentation RealmEventsConfigRepresentation) ApiAdminRealmsRealmEventsConfigPutRequest {
	r.realmEventsConfigRepresentation = &realmEventsConfigRepresentation
	return r
}

func (r ApiAdminRealmsRealmEventsConfigPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsConfigPutExecute(r)
}

/*
AdminRealmsRealmEventsConfigPut Method for AdminRealmsRealmEventsConfigPut

Update the events provider Change the events provider and/or its configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmEventsConfigPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigPut(ctx context.Context, realm string) ApiAdminRealmsRealmEventsConfigPutRequest {
	return ApiAdminRealmsRealmEventsConfigPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsConfigPutExecute(r ApiAdminRealmsRealmEventsConfigPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsConfigPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.realmEventsConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmEventsDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmEventsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsDeleteExecute(r)
}

/*
AdminRealmsRealmEventsDelete Delete all events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmEventsDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsDelete(ctx context.Context, realm string) ApiAdminRealmsRealmEventsDeleteRequest {
	return ApiAdminRealmsRealmEventsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsDeleteExecute(r ApiAdminRealmsRealmEventsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmEventsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	client *string
	dateFrom *string
	dateTo *string
	first *int32
	ipAddress *string
	max *int32
	type_ *[]string
	user *string
}

// App or oauth client name
func (r ApiAdminRealmsRealmEventsGetRequest) Client(client string) ApiAdminRealmsRealmEventsGetRequest {
	r.client = &client
	return r
}

// From date
func (r ApiAdminRealmsRealmEventsGetRequest) DateFrom(dateFrom string) ApiAdminRealmsRealmEventsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// To date
func (r ApiAdminRealmsRealmEventsGetRequest) DateTo(dateTo string) ApiAdminRealmsRealmEventsGetRequest {
	r.dateTo = &dateTo
	return r
}

// Paging offset
func (r ApiAdminRealmsRealmEventsGetRequest) First(first int32) ApiAdminRealmsRealmEventsGetRequest {
	r.first = &first
	return r
}

// IP Address
func (r ApiAdminRealmsRealmEventsGetRequest) IpAddress(ipAddress string) ApiAdminRealmsRealmEventsGetRequest {
	r.ipAddress = &ipAddress
	return r
}

// Maximum results size (defaults to 100)
func (r ApiAdminRealmsRealmEventsGetRequest) Max(max int32) ApiAdminRealmsRealmEventsGetRequest {
	r.max = &max
	return r
}

// The types of events to return
func (r ApiAdminRealmsRealmEventsGetRequest) Type_(type_ []string) ApiAdminRealmsRealmEventsGetRequest {
	r.type_ = &type_
	return r
}

// User id
func (r ApiAdminRealmsRealmEventsGetRequest) User(user string) ApiAdminRealmsRealmEventsGetRequest {
	r.user = &user
	return r
}

func (r ApiAdminRealmsRealmEventsGetRequest) Execute() ([]EventRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmEventsGetExecute(r)
}

/*
AdminRealmsRealmEventsGet Get events Returns all events, or filters them based on URL query parameters listed here

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmEventsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsGet(ctx context.Context, realm string) ApiAdminRealmsRealmEventsGetRequest {
	return ApiAdminRealmsRealmEventsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []EventRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmEventsGetExecute(r ApiAdminRealmsRealmEventsGetRequest) ([]EventRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EventRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.client != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client", r.client, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateFrom", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateTo", r.dateTo, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipAddress", r.ipAddress, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmGetRequest) Execute() (*RealmRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGetExecute(r)
}

/*
AdminRealmsRealmGet Get the top-level representation of the realm It will not include nested information like User and Client representations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmGet(ctx context.Context, realm string) ApiAdminRealmsRealmGetRequest {
	return ApiAdminRealmsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return RealmRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmGetExecute(r ApiAdminRealmsRealmGetRequest) (*RealmRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RealmRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupByPathPathGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	path []PathSegment
}

func (r ApiAdminRealmsRealmGroupByPathPathGetRequest) Execute() (*GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupByPathPathGetExecute(r)
}

/*
AdminRealmsRealmGroupByPathPathGet Method for AdminRealmsRealmGroupByPathPathGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param path
 @return ApiAdminRealmsRealmGroupByPathPathGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmGroupByPathPathGet(ctx context.Context, realm string, path []PathSegment) ApiAdminRealmsRealmGroupByPathPathGetRequest {
	return ApiAdminRealmsRealmGroupByPathPathGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		path: path,
	}
}

// Execute executes the request
//  @return GroupRepresentation
func (a *RealmsAdminAPIService) AdminRealmsRealmGroupByPathPathGetExecute(r ApiAdminRealmsRealmGroupByPathPathGetRequest) (*GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmGroupByPathPathGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/group-by-path/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLocalizationGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmLocalizationGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationGetExecute(r)
}

/*
AdminRealmsRealmLocalizationGet Method for AdminRealmsRealmLocalizationGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmLocalizationGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationGet(ctx context.Context, realm string) ApiAdminRealmsRealmLocalizationGetRequest {
	return ApiAdminRealmsRealmLocalizationGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []string
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationGetExecute(r ApiAdminRealmsRealmLocalizationGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLocalizationLocaleDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	locale string
}

func (r ApiAdminRealmsRealmLocalizationLocaleDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleDeleteExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleDelete Method for AdminRealmsRealmLocalizationLocaleDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param locale
 @return ApiAdminRealmsRealmLocalizationLocaleDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleDelete(ctx context.Context, realm string, locale string) ApiAdminRealmsRealmLocalizationLocaleDeleteRequest {
	return ApiAdminRealmsRealmLocalizationLocaleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleDeleteExecute(r ApiAdminRealmsRealmLocalizationLocaleDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLocalizationLocaleGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	locale string
	useRealmDefaultLocaleFallback *bool
}

// Deprecated
func (r ApiAdminRealmsRealmLocalizationLocaleGetRequest) UseRealmDefaultLocaleFallback(useRealmDefaultLocaleFallback bool) ApiAdminRealmsRealmLocalizationLocaleGetRequest {
	r.useRealmDefaultLocaleFallback = &useRealmDefaultLocaleFallback
	return r
}

func (r ApiAdminRealmsRealmLocalizationLocaleGetRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleGetExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleGet Method for AdminRealmsRealmLocalizationLocaleGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param locale
 @return ApiAdminRealmsRealmLocalizationLocaleGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleGet(ctx context.Context, realm string, locale string) ApiAdminRealmsRealmLocalizationLocaleGetRequest {
	return ApiAdminRealmsRealmLocalizationLocaleGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		locale: locale,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleGetExecute(r ApiAdminRealmsRealmLocalizationLocaleGetRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useRealmDefaultLocaleFallback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useRealmDefaultLocaleFallback", r.useRealmDefaultLocaleFallback, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLocalizationLocaleKeyDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	key string
	locale string
}

func (r ApiAdminRealmsRealmLocalizationLocaleKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleKeyDeleteExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleKeyDelete Method for AdminRealmsRealmLocalizationLocaleKeyDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param key
 @param locale
 @return ApiAdminRealmsRealmLocalizationLocaleKeyDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyDelete(ctx context.Context, realm string, key string, locale string) ApiAdminRealmsRealmLocalizationLocaleKeyDeleteRequest {
	return ApiAdminRealmsRealmLocalizationLocaleKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		key: key,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyDeleteExecute(r ApiAdminRealmsRealmLocalizationLocaleKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleKeyDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLocalizationLocaleKeyGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	key string
	locale string
}

func (r ApiAdminRealmsRealmLocalizationLocaleKeyGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleKeyGetExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleKeyGet Method for AdminRealmsRealmLocalizationLocaleKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param key
 @param locale
 @return ApiAdminRealmsRealmLocalizationLocaleKeyGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyGet(ctx context.Context, realm string, key string, locale string) ApiAdminRealmsRealmLocalizationLocaleKeyGetRequest {
	return ApiAdminRealmsRealmLocalizationLocaleKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		key: key,
		locale: locale,
	}
}

// Execute executes the request
//  @return string
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyGetExecute(r ApiAdminRealmsRealmLocalizationLocaleKeyGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	key string
	locale string
	body *string
}

func (r ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest) Body(body string) ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest {
	r.body = &body
	return r
}

func (r ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocaleKeyPutExecute(r)
}

/*
AdminRealmsRealmLocalizationLocaleKeyPut Method for AdminRealmsRealmLocalizationLocaleKeyPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param key
 @param locale
 @return ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyPut(ctx context.Context, realm string, key string, locale string) ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest {
	return ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		key: key,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocaleKeyPutExecute(r ApiAdminRealmsRealmLocalizationLocaleKeyPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocaleKeyPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLocalizationLocalePostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	locale string
	requestBody *map[string]string
}

func (r ApiAdminRealmsRealmLocalizationLocalePostRequest) RequestBody(requestBody map[string]string) ApiAdminRealmsRealmLocalizationLocalePostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmLocalizationLocalePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmLocalizationLocalePostExecute(r)
}

/*
AdminRealmsRealmLocalizationLocalePost Import localization from uploaded JSON file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param locale
 @return ApiAdminRealmsRealmLocalizationLocalePostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocalePost(ctx context.Context, realm string, locale string) ApiAdminRealmsRealmLocalizationLocalePostRequest {
	return ApiAdminRealmsRealmLocalizationLocalePostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		locale: locale,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmLocalizationLocalePostExecute(r ApiAdminRealmsRealmLocalizationLocalePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLocalizationLocalePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/localization/{locale}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmLogoutAllPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmLogoutAllPostRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmLogoutAllPostExecute(r)
}

/*
AdminRealmsRealmLogoutAllPost Removes all user sessions.

Any client that has an admin url will also be told to invalidate any sessions they have.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmLogoutAllPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmLogoutAllPost(ctx context.Context, realm string) ApiAdminRealmsRealmLogoutAllPostRequest {
	return ApiAdminRealmsRealmLogoutAllPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *RealmsAdminAPIService) AdminRealmsRealmLogoutAllPostExecute(r ApiAdminRealmsRealmLogoutAllPostRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmLogoutAllPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/logout-all"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmPartialExportPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	exportClients *bool
	exportGroupsAndRoles *bool
}

func (r ApiAdminRealmsRealmPartialExportPostRequest) ExportClients(exportClients bool) ApiAdminRealmsRealmPartialExportPostRequest {
	r.exportClients = &exportClients
	return r
}

func (r ApiAdminRealmsRealmPartialExportPostRequest) ExportGroupsAndRoles(exportGroupsAndRoles bool) ApiAdminRealmsRealmPartialExportPostRequest {
	r.exportGroupsAndRoles = &exportGroupsAndRoles
	return r
}

func (r ApiAdminRealmsRealmPartialExportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmPartialExportPostExecute(r)
}

/*
AdminRealmsRealmPartialExportPost Partial export of existing realm into a JSON file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmPartialExportPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialExportPost(ctx context.Context, realm string) ApiAdminRealmsRealmPartialExportPostRequest {
	return ApiAdminRealmsRealmPartialExportPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialExportPostExecute(r ApiAdminRealmsRealmPartialExportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPartialExportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/partial-export"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exportClients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportClients", r.exportClients, "")
	}
	if r.exportGroupsAndRoles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportGroupsAndRoles", r.exportGroupsAndRoles, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmPartialImportPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	body *os.File
}

func (r ApiAdminRealmsRealmPartialImportPostRequest) Body(body *os.File) ApiAdminRealmsRealmPartialImportPostRequest {
	r.body = body
	return r
}

func (r ApiAdminRealmsRealmPartialImportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmPartialImportPostExecute(r)
}

/*
AdminRealmsRealmPartialImportPost Partial import from a JSON file to an existing realm.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmPartialImportPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialImportPost(ctx context.Context, realm string) ApiAdminRealmsRealmPartialImportPostRequest {
	return ApiAdminRealmsRealmPartialImportPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmPartialImportPostExecute(r ApiAdminRealmsRealmPartialImportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPartialImportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/partialImport"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmPushRevocationPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmPushRevocationPostRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmPushRevocationPostExecute(r)
}

/*
AdminRealmsRealmPushRevocationPost Push the realm's revocation policy to any client that has an admin url associated with it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmPushRevocationPostRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPushRevocationPost(ctx context.Context, realm string) ApiAdminRealmsRealmPushRevocationPostRequest {
	return ApiAdminRealmsRealmPushRevocationPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *RealmsAdminAPIService) AdminRealmsRealmPushRevocationPostExecute(r ApiAdminRealmsRealmPushRevocationPostRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPushRevocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/push-revocation"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	realmRepresentation *RealmRepresentation
}

func (r ApiAdminRealmsRealmPutRequest) RealmRepresentation(realmRepresentation RealmRepresentation) ApiAdminRealmsRealmPutRequest {
	r.realmRepresentation = &realmRepresentation
	return r
}

func (r ApiAdminRealmsRealmPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmPutExecute(r)
}

/*
AdminRealmsRealmPut Update the top-level information of the realm Any user, roles or client information in the representation will be ignored.

This will only update top-level attributes of the realm.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmPut(ctx context.Context, realm string) ApiAdminRealmsRealmPutRequest {
	return ApiAdminRealmsRealmPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmPutExecute(r ApiAdminRealmsRealmPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.realmRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmSessionsSessionDeleteRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	session string
	isOffline *bool
}

func (r ApiAdminRealmsRealmSessionsSessionDeleteRequest) IsOffline(isOffline bool) ApiAdminRealmsRealmSessionsSessionDeleteRequest {
	r.isOffline = &isOffline
	return r
}

func (r ApiAdminRealmsRealmSessionsSessionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmSessionsSessionDeleteExecute(r)
}

/*
AdminRealmsRealmSessionsSessionDelete Remove a specific user session.

Any client that has an admin url will also be told to invalidate this particular session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param session
 @return ApiAdminRealmsRealmSessionsSessionDeleteRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmSessionsSessionDelete(ctx context.Context, realm string, session string) ApiAdminRealmsRealmSessionsSessionDeleteRequest {
	return ApiAdminRealmsRealmSessionsSessionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		session: session,
	}
}

// Execute executes the request
func (a *RealmsAdminAPIService) AdminRealmsRealmSessionsSessionDeleteExecute(r ApiAdminRealmsRealmSessionsSessionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmSessionsSessionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/sessions/{session}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session"+"}", url.PathEscape(parameterValueToString(r.session, "session")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isOffline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isOffline", r.isOffline, "")
	} else {
		var defaultValue bool = false
		r.isOffline = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmTestSMTPConnectionPostRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	requestBody *map[string]string
}

func (r ApiAdminRealmsRealmTestSMTPConnectionPostRequest) RequestBody(requestBody map[string]string) ApiAdminRealmsRealmTestSMTPConnectionPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmTestSMTPConnectionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmTestSMTPConnectionPostExecute(r)
}

/*
AdminRealmsRealmTestSMTPConnectionPost Test SMTP connection with current logged in user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmTestSMTPConnectionPostRequest

Deprecated
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmTestSMTPConnectionPost(ctx context.Context, realm string) ApiAdminRealmsRealmTestSMTPConnectionPostRequest {
	return ApiAdminRealmsRealmTestSMTPConnectionPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
// Deprecated
func (a *RealmsAdminAPIService) AdminRealmsRealmTestSMTPConnectionPostExecute(r ApiAdminRealmsRealmTestSMTPConnectionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmTestSMTPConnectionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/testSMTPConnection"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
}

func (r ApiAdminRealmsRealmUsersManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmUsersManagementPermissionsGet Method for AdminRealmsRealmUsersManagementPermissionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersManagementPermissionsGetRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsGet(ctx context.Context, realm string) ApiAdminRealmsRealmUsersManagementPermissionsGetRequest {
	return ApiAdminRealmsRealmUsersManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsGetExecute(r ApiAdminRealmsRealmUsersManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmUsersManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users-management-permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *RealmsAdminAPIService
	realm string
	managementPermissionReference *ManagementPermissionReference
}

func (r ApiAdminRealmsRealmUsersManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ApiAdminRealmsRealmUsersManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ApiAdminRealmsRealmUsersManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmUsersManagementPermissionsPut Method for AdminRealmsRealmUsersManagementPermissionsPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmUsersManagementPermissionsPutRequest
*/
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsPut(ctx context.Context, realm string) ApiAdminRealmsRealmUsersManagementPermissionsPutRequest {
	return ApiAdminRealmsRealmUsersManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RealmsAdminAPIService) AdminRealmsRealmUsersManagementPermissionsPutExecute(r ApiAdminRealmsRealmUsersManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealmsAdminAPIService.AdminRealmsRealmUsersManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users-management-permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
