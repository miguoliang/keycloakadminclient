/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RolesAPIService RolesAPI service
type RolesAPIService service

type RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	briefRepresentation *bool
	first *int32
	max *int32
	search *string
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest) BriefRepresentation(briefRepresentation bool) RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest) First(first int32) RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.first = &first
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest) Max(max int32) RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.max = &max
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest) Search(search string) RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest {
	r.search = &search
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesGet Get all roles for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesGet(ctx context.Context, realm string, clientUuid string) RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	} else {
		var defaultValue string = ""
		r.search = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleRepresentation *RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest) RoleRepresentation(roleRepresentation RoleRepresentation) RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesPost Create a new role for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesPost(ctx context.Context, realm string, clientUuid string) RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesPostExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGet Get client-level roles for the client that are in the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesClientsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDelete Remove roles from the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDelete(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGet Get composites of the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPost Add a composite to the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPost(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGet Get realm-level roles of the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameCompositesRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/composites/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameDelete Delete a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameDelete(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameDeleteExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest) Execute() (*RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameGet Get a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGetRequest) (*RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	briefRepresentation *bool
	first *int32
	max *int32
}

// if false, return a full representation of the {@code GroupRepresentation} objects.
func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) BriefRepresentation(briefRepresentation bool) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// first result to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) First(first int32) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) Max(max int32) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	r.max = &max
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGet Returns a stream of groups that have the specified role name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName the role name.
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGet Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	managementPermissionReference *ManagementPermissionReference
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPut Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPut(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	roleRepresentation *RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest) RoleRepresentation(roleRepresentation RoleRepresentation) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNamePutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNamePut Update a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNamePut(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNamePutExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
	first *int32
	max *int32
}

// first result to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) First(first int32) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) Max(max int32) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest {
	r.max = &max
	return r
}

func (r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGet Returns a stream of users that have the specified role name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleName the role name.
 @return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest {
	return RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []UserRepresentation
func (a *RolesAPIService) AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetExecute(r RolesAPIAdminRealmsRealmClientsClientUuidRolesRoleNameUsersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmClientsClientUuidRolesRoleNameUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/roles/{role-name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	briefRepresentation *bool
	first *int32
	max *int32
	search *string
}

func (r RolesAPIAdminRealmsRealmRolesGetRequest) BriefRepresentation(briefRepresentation bool) RolesAPIAdminRealmsRealmRolesGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmRolesGetRequest) First(first int32) RolesAPIAdminRealmsRealmRolesGetRequest {
	r.first = &first
	return r
}

func (r RolesAPIAdminRealmsRealmRolesGetRequest) Max(max int32) RolesAPIAdminRealmsRealmRolesGetRequest {
	r.max = &max
	return r
}

func (r RolesAPIAdminRealmsRealmRolesGetRequest) Search(search string) RolesAPIAdminRealmsRealmRolesGetRequest {
	r.search = &search
	return r
}

func (r RolesAPIAdminRealmsRealmRolesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesGetExecute(r)
}

/*
AdminRealmsRealmRolesGet Get all roles for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RolesAPIAdminRealmsRealmRolesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesGet(ctx context.Context, realm string) RolesAPIAdminRealmsRealmRolesGetRequest {
	return RolesAPIAdminRealmsRealmRolesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesGetExecute(r RolesAPIAdminRealmsRealmRolesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	} else {
		var defaultValue string = ""
		r.search = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleRepresentation *RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmRolesPostRequest) RoleRepresentation(roleRepresentation RoleRepresentation) RolesAPIAdminRealmsRealmRolesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesPostExecute(r)
}

/*
AdminRealmsRealmRolesPost Create a new role for the realm or client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return RolesAPIAdminRealmsRealmRolesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesPost(ctx context.Context, realm string) RolesAPIAdminRealmsRealmRolesPostRequest {
	return RolesAPIAdminRealmsRealmRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesPostExecute(r RolesAPIAdminRealmsRealmRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	clientUuid string
	roleName string
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGet Get client-level roles for the client that are in the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGet(ctx context.Context, realm string, clientUuid string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetExecute(r RolesAPIAdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesClientsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesDeleteExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesDelete Remove roles from the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesDelete(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesDeleteExecute(r RolesAPIAdminRealmsRealmRolesRoleNameCompositesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameCompositesGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameCompositesGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesGet Get composites of the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNameCompositesGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesGet(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameCompositesGetRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameCompositesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesGetExecute(r RolesAPIAdminRealmsRealmRolesRoleNameCompositesGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	roleRepresentation *[]RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesPostExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesPost Add a composite to the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesPost(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesPostExecute(r RolesAPIAdminRealmsRealmRolesRoleNameCompositesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameCompositesRealmGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameCompositesRealmGet Get realm-level roles of the role's composite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesRealmGet(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameCompositesRealmGetExecute(r RolesAPIAdminRealmsRealmRolesRoleNameCompositesRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameCompositesRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/composites/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameDeleteRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameDeleteExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameDelete Delete a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNameDeleteRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameDelete(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameDeleteRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameDeleteExecute(r RolesAPIAdminRealmsRealmRolesRoleNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameGetRequest) Execute() (*RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameGet Get a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNameGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGet(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameGetRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RoleRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGetExecute(r RolesAPIAdminRealmsRealmRolesRoleNameGetRequest) (*RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	briefRepresentation *bool
	first *int32
	max *int32
}

// if false, return a full representation of the {@code GroupRepresentation} objects.
func (r RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest) BriefRepresentation(briefRepresentation bool) RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// first result to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest) First(first int32) RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest) Max(max int32) RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	r.max = &max
	return r
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameGroupsGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameGroupsGet Returns a stream of groups that have the specified role name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName the role name.
 @return RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGroupsGet(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameGroupsGetExecute(r RolesAPIAdminRealmsRealmRolesRoleNameGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameManagementPermissionsGet Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName
 @return RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsGet(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsGetExecute(r RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	managementPermissionReference *ManagementPermissionReference
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameManagementPermissionsPut Return object stating whether role Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName
 @return RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsPut(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameManagementPermissionsPutExecute(r RolesAPIAdminRealmsRealmRolesRoleNameManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNamePutRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	roleRepresentation *RoleRepresentation
}

func (r RolesAPIAdminRealmsRealmRolesRoleNamePutRequest) RoleRepresentation(roleRepresentation RoleRepresentation) RolesAPIAdminRealmsRealmRolesRoleNamePutRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r RolesAPIAdminRealmsRealmRolesRoleNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNamePutExecute(r)
}

/*
AdminRealmsRealmRolesRoleNamePut Update a role by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName role's name (not id!)
 @return RolesAPIAdminRealmsRealmRolesRoleNamePutRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNamePut(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNamePutRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNamePutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNamePutExecute(r RolesAPIAdminRealmsRealmRolesRoleNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest struct {
	ctx context.Context
	ApiService *RolesAPIService
	realm string
	roleName string
	first *int32
	max *int32
}

// first result to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest) First(first int32) RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest) Max(max int32) RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest {
	r.max = &max
	return r
}

func (r RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmRolesRoleNameUsersGetExecute(r)
}

/*
AdminRealmsRealmRolesRoleNameUsersGet Returns a stream of users that have the specified role name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param roleName the role name.
 @return RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest
*/
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameUsersGet(ctx context.Context, realm string, roleName string) RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest {
	return RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []UserRepresentation
func (a *RolesAPIService) AdminRealmsRealmRolesRoleNameUsersGetExecute(r RolesAPIAdminRealmsRealmRolesRoleNameUsersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.AdminRealmsRealmRolesRoleNameUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/roles/{role-name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
