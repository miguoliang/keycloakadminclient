/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ClientsAPIService ClientsAPI service
type ClientsAPIService service

type ApiAdminRealmsRealmClientsClientUuidClientSecretGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidClientSecretGetRequest) Execute() (*CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretGet Get the client secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidClientSecretGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidClientSecretGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidClientSecretGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return CredentialRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretGetExecute(r ApiAdminRealmsRealmClientsClientUuidClientSecretGetRequest) (*CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidClientSecretPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidClientSecretPostRequest) Execute() (*CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretPost Generate a new secret for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidClientSecretPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretPost(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidClientSecretPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidClientSecretPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return CredentialRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretPostExecute(r ApiAdminRealmsRealmClientsClientUuidClientSecretPostRequest) (*CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretRotatedDelete Invalidate the rotated secret for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedDelete(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretRotatedDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret/rotated"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest) Execute() (*CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretRotatedGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretRotatedGet Get the rotated client secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return CredentialRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedGetExecute(r ApiAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest) (*CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretRotatedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret/rotated"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete Method for AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientUuid string, clientScopeId string) ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut Method for AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut(ctx context.Context, realm string, clientUuid string, clientScopeId string) ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest {
	return ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutExecute(r ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDefaultClientScopesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDefaultClientScopesGet Get default client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesGetExecute(r ApiAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDefaultClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDelete Delete the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDelete(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
	userId *string
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) Scope(scope string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest {
	r.scope = &scope
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) UserId(userId string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest {
	r.userId = &userId
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) Execute() (*AccessToken, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet Create JSON with payload of example access token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return AccessToken
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetExecute(r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) (*AccessToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-access-token"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
	userId *string
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) Scope(scope string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest {
	r.scope = &scope
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) UserId(userId string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest {
	r.userId = &userId
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) Execute() (*IDToken, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet Create JSON with payload of example id token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return IDToken
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetExecute(r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) (*IDToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IDToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-id-token"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
	userId *string
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) Scope(scope string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest {
	r.scope = &scope
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) UserId(userId string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest {
	r.userId = &userId
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet Create JSON with payload of example user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetExecute(r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-userinfo"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest) Scope(scope string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest {
	r.scope = &scope
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest) Execute() ([]ProtocolMapperEvaluationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet Return list of all protocol mappers, which will be used when generating tokens issued for particular client.

This means protocol mappers assigned to this client directly and protocol mappers assigned to all client scopes of this client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []ProtocolMapperEvaluationRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetExecute(r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest) ([]ProtocolMapperEvaluationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProtocolMapperEvaluationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/protocol-mappers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	roleContainerId string
	scope *string
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest) Scope(scope string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest {
	r.scope = &scope
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.

This contains scope mappings, which this client has directly, as well as scope mappings, which are granted to all client scopes, which are linked with this client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleContainerId either realm name OR client UUID
 @return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(ctx context.Context, realm string, clientUuid string, roleContainerId string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleContainerId: roleContainerId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetExecute(r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/scope-mappings/{roleContainerId}/granted"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleContainerId"+"}", url.PathEscape(parameterValueToString(r.roleContainerId, "roleContainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	roleContainerId string
	scope *string
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest) Scope(scope string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest {
	r.scope = &scope
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet Get roles, which this client doesn't have scope for and can't have them in the accessToken issued for him.

Defacto all the other roles of particular role container, which are not in {@link #getGrantedScopeMappings()}

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleContainerId either realm name OR client UUID
 @return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(ctx context.Context, realm string, clientUuid string, roleContainerId string) ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleContainerId: roleContainerId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetExecute(r ApiAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/scope-mappings/{roleContainerId}/not-granted"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleContainerId"+"}", url.PathEscape(parameterValueToString(r.roleContainerId, "roleContainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidGetRequest) Execute() (*ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidGet Get representation of the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ClientRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidGetExecute(r ApiAdminRealmsRealmClientsClientUuidGetRequest) (*ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	providerId string
}

func (r ApiAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet Method for AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param providerId
 @return ApiAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet(ctx context.Context, realm string, clientUuid string, providerId string) ApiAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		providerId: providerId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetExecute(r ApiAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/installation/providers/{providerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"providerId"+"}", url.PathEscape(parameterValueToString(r.providerId, "providerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidManagementPermissionsGet Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsGetExecute(r ApiAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	managementPermissionReference *ManagementPermissionReference
}

func (r ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidManagementPermissionsPut Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsPut(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest {
	return ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsPutExecute(r ApiAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	node string
}

func (r ApiAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidNodesNodeDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidNodesNodeDelete Unregister a cluster node from the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param node
 @return ApiAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesNodeDelete(ctx context.Context, realm string, clientUuid string, node string) ApiAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		node: node,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesNodeDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidNodesNodeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/nodes/{node}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidNodesPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	requestBody *map[string]string
}

func (r ApiAdminRealmsRealmClientsClientUuidNodesPostRequest) RequestBody(requestBody map[string]string) ApiAdminRealmsRealmClientsClientUuidNodesPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidNodesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidNodesPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidNodesPost Register a cluster node with the client Manually register cluster node to this client - usually its not needed to call this directly as adapter should handle by sending registration request to Keycloak

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidNodesPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesPost(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidNodesPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidNodesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesPostExecute(r ApiAdminRealmsRealmClientsClientUuidNodesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidNodesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOfflineSessionCountGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOfflineSessionCountGet Get application offline session count Returns a number of offline user sessions associated with this client { \"count\": number }

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionCountGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionCountGetExecute(r ApiAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOfflineSessionCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/offline-session-count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	first *int32
	max *int32
}

// Paging offset
func (r ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) First(first int32) ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) Max(max int32) ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOfflineSessionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOfflineSessionsGet Get offline sessions for client Returns a list of offline user sessions associated with this client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionsGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []UserSessionRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionsGetExecute(r ApiAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOfflineSessionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/offline-sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete Method for AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientUuid string, clientScopeId string) ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest {
	return ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteExecute(r ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut Method for AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut(ctx context.Context, realm string, clientUuid string, clientScopeId string) ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest {
	return ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutExecute(r ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOptionalClientScopesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOptionalClientScopesGet Get optional client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesGetExecute(r ApiAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOptionalClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidPushRevocationPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidPushRevocationPostRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidPushRevocationPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidPushRevocationPost Push the client's revocation policy to its admin URL If the client has an admin URL, push revocation policy to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidPushRevocationPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPushRevocationPost(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidPushRevocationPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidPushRevocationPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPushRevocationPostExecute(r ApiAdminRealmsRealmClientsClientUuidPushRevocationPostRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidPushRevocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/push-revocation"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientRepresentation *ClientRepresentation
}

func (r ApiAdminRealmsRealmClientsClientUuidPutRequest) ClientRepresentation(clientRepresentation ClientRepresentation) ApiAdminRealmsRealmClientsClientUuidPutRequest {
	r.clientRepresentation = &clientRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidPut Update the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPut(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidPutRequest {
	return ApiAdminRealmsRealmClientsClientUuidPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPutExecute(r ApiAdminRealmsRealmClientsClientUuidPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest) Execute() (*ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPost Generate a new registration access token for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPost(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest {
	return ApiAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ClientRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostExecute(r ApiAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest) (*ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/registration-access-token"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest) Execute() (*UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidServiceAccountUserGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidServiceAccountUserGet Get a user dedicated to the service account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidServiceAccountUserGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return UserRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidServiceAccountUserGetExecute(r ApiAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest) (*UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidServiceAccountUserGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/service-account-user"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidSessionCountGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidSessionCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidSessionCountGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidSessionCountGet Get application session count Returns a number of user sessions associated with this client { \"count\": number }

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidSessionCountGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidSessionCountGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidSessionCountGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidSessionCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidSessionCountGetExecute(r ApiAdminRealmsRealmClientsClientUuidSessionCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidSessionCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/session-count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ApiAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidTestNodesAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidTestNodesAvailableGet Test if registered cluster nodes are available Tests availability by sending 'ping' request to all cluster nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidTestNodesAvailableGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidTestNodesAvailableGetExecute(r ApiAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidTestNodesAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/test-nodes-available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	first *int32
	max *int32
}

// Paging offset
func (r ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) First(first int32) ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) Max(max int32) ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidUserSessionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidUserSessionsGet Get user sessions for client Returns a list of user sessions associated with this client 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidUserSessionsGet(ctx context.Context, realm string, clientUuid string) ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest {
	return ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []UserSessionRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidUserSessionsGetExecute(r ApiAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidUserSessionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/user-sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientId *string
	first *int32
	max *int32
	q *string
	search *bool
	viewableOnly *bool
}

// filter by clientId
func (r ApiAdminRealmsRealmClientsGetRequest) ClientId(clientId string) ApiAdminRealmsRealmClientsGetRequest {
	r.clientId = &clientId
	return r
}

// the first result
func (r ApiAdminRealmsRealmClientsGetRequest) First(first int32) ApiAdminRealmsRealmClientsGetRequest {
	r.first = &first
	return r
}

// the max results to return
func (r ApiAdminRealmsRealmClientsGetRequest) Max(max int32) ApiAdminRealmsRealmClientsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmClientsGetRequest) Q(q string) ApiAdminRealmsRealmClientsGetRequest {
	r.q = &q
	return r
}

// whether this is a search query or a getClientById query
func (r ApiAdminRealmsRealmClientsGetRequest) Search(search bool) ApiAdminRealmsRealmClientsGetRequest {
	r.search = &search
	return r
}

// filter clients that cannot be viewed in full by admin
func (r ApiAdminRealmsRealmClientsGetRequest) ViewableOnly(viewableOnly bool) ApiAdminRealmsRealmClientsGetRequest {
	r.viewableOnly = &viewableOnly
	return r
}

func (r ApiAdminRealmsRealmClientsGetRequest) Execute() ([]ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsGetExecute(r)
}

/*
AdminRealmsRealmClientsGet Get clients belonging to the realm.

If a client cant be retrieved from the storage due to a problem with the underlying storage, it is silently removed from the returned list. This ensures that concurrent modifications to the list dont prevent callers from retrieving this list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsGet(ctx context.Context, realm string) ApiAdminRealmsRealmClientsGetRequest {
	return ApiAdminRealmsRealmClientsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []ClientRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsGetExecute(r ApiAdminRealmsRealmClientsGetRequest) ([]ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientId", r.clientId, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	} else {
		var defaultValue bool = false
		r.search = &defaultValue
	}
	if r.viewableOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewableOnly", r.viewableOnly, "")
	} else {
		var defaultValue bool = false
		r.viewableOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmClientsPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientRepresentation *ClientRepresentation
}

func (r ApiAdminRealmsRealmClientsPostRequest) ClientRepresentation(clientRepresentation ClientRepresentation) ApiAdminRealmsRealmClientsPostRequest {
	r.clientRepresentation = &clientRepresentation
	return r
}

func (r ApiAdminRealmsRealmClientsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsPostExecute(r)
}

/*
AdminRealmsRealmClientsPost Create a new client Clients client_id must be unique!

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmClientsPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsPost(ctx context.Context, realm string) ApiAdminRealmsRealmClientsPostRequest {
	return ApiAdminRealmsRealmClientsPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsPostExecute(r ApiAdminRealmsRealmClientsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
