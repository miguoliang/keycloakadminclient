/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GroupsAPIService GroupsAPI service
type GroupsAPIService service

type ApiAdminRealmsRealmGroupsCountGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	search *string
	top *bool
}

func (r ApiAdminRealmsRealmGroupsCountGetRequest) Search(search string) ApiAdminRealmsRealmGroupsCountGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmGroupsCountGetRequest) Top(top bool) ApiAdminRealmsRealmGroupsCountGetRequest {
	r.top = &top
	return r
}

func (r ApiAdminRealmsRealmGroupsCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsCountGetExecute(r)
}

/*
AdminRealmsRealmGroupsCountGet Returns the groups counts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmGroupsCountGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsCountGet(ctx context.Context, realm string) ApiAdminRealmsRealmGroupsCountGetRequest {
	return ApiAdminRealmsRealmGroupsCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *GroupsAPIService) AdminRealmsRealmGroupsCountGetExecute(r ApiAdminRealmsRealmGroupsCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.top != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top", r.top, "")
	} else {
		var defaultValue bool = false
		r.top = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	briefRepresentation *bool
	exact *bool
	first *int32
	max *int32
	populateHierarchy *bool
	q *string
	search *string
}

func (r ApiAdminRealmsRealmGroupsGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsGetRequest) Exact(exact bool) ApiAdminRealmsRealmGroupsGetRequest {
	r.exact = &exact
	return r
}

func (r ApiAdminRealmsRealmGroupsGetRequest) First(first int32) ApiAdminRealmsRealmGroupsGetRequest {
	r.first = &first
	return r
}

func (r ApiAdminRealmsRealmGroupsGetRequest) Max(max int32) ApiAdminRealmsRealmGroupsGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmGroupsGetRequest) PopulateHierarchy(populateHierarchy bool) ApiAdminRealmsRealmGroupsGetRequest {
	r.populateHierarchy = &populateHierarchy
	return r
}

func (r ApiAdminRealmsRealmGroupsGetRequest) Q(q string) ApiAdminRealmsRealmGroupsGetRequest {
	r.q = &q
	return r
}

func (r ApiAdminRealmsRealmGroupsGetRequest) Search(search string) ApiAdminRealmsRealmGroupsGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGetExecute(r)
}

/*
AdminRealmsRealmGroupsGet Get group hierarchy.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmGroupsGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGet(ctx context.Context, realm string) ApiAdminRealmsRealmGroupsGetRequest {
	return ApiAdminRealmsRealmGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGetExecute(r ApiAdminRealmsRealmGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "")
	} else {
		var defaultValue bool = false
		r.exact = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.populateHierarchy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "populateHierarchy", r.populateHierarchy, "")
	} else {
		var defaultValue bool = true
		r.populateHierarchy = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	briefRepresentation *bool
	first *int32
	max *int32
}

func (r ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest) First(first int32) ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	r.first = &first
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest) Max(max int32) ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdChildrenGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdChildrenGet Return a paginated list of subgroups that have a parent group corresponding to the group on the URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenGetExecute(r ApiAdminRealmsRealmGroupsGroupIdChildrenGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdChildrenGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = false
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	groupRepresentation *GroupRepresentation
}

func (r ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest) GroupRepresentation(groupRepresentation GroupRepresentation) ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest {
	r.groupRepresentation = &groupRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdChildrenPostExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdChildrenPost Set or create child.

This will just set the parent if it exists. Create it and set the parent if the group doesnâ€™t exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenPost(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest {
	return ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenPostExecute(r ApiAdminRealmsRealmGroupsGroupIdChildrenPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdChildrenPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmGroupsGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdDeleteExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdDelete Method for AdminRealmsRealmGroupsGroupIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdDeleteRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdDelete(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdDeleteRequest {
	return ApiAdminRealmsRealmGroupsGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdDeleteExecute(r ApiAdminRealmsRealmGroupsGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmGroupsGroupIdGetRequest) Execute() (*GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdGet Method for AdminRealmsRealmGroupsGroupIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GroupRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdGetExecute(r ApiAdminRealmsRealmGroupsGroupIdGetRequest) (*GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdManagementPermissionsGet Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsGetExecute(r ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	managementPermissionReference *ManagementPermissionReference
}

func (r ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdManagementPermissionsPut Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsPut(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest {
	return ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsPutExecute(r ApiAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	briefRepresentation *bool
	first *int32
	max *int32
}

// Only return basic information (only guaranteed to return id, username, created, first and last name, email, enabled state, email verification state, federation link, and access. Note that it means that namely user attributes, required actions, and not before are not returned.)
func (r ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// Pagination offset
func (r ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest) First(first int32) ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest) Max(max int32) ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	r.max = &max
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdMembersGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdMembersGet Get users Returns a stream of users, filtered according to query parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdMembersGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []UserRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdMembersGetExecute(r ApiAdminRealmsRealmGroupsGroupIdMembersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdMembersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdPutRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	groupRepresentation *GroupRepresentation
}

func (r ApiAdminRealmsRealmGroupsGroupIdPutRequest) GroupRepresentation(groupRepresentation GroupRepresentation) ApiAdminRealmsRealmGroupsGroupIdPutRequest {
	r.groupRepresentation = &groupRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdPutExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdPut Update group, ignores subgroups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdPutRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdPut(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdPutRequest {
	return ApiAdminRealmsRealmGroupsGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdPutExecute(r ApiAdminRealmsRealmGroupsGroupIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsPostRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupRepresentation *GroupRepresentation
}

func (r ApiAdminRealmsRealmGroupsPostRequest) GroupRepresentation(groupRepresentation GroupRepresentation) ApiAdminRealmsRealmGroupsPostRequest {
	r.groupRepresentation = &groupRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsPostExecute(r)
}

/*
AdminRealmsRealmGroupsPost create or add a top level realm groupSet or create child.

This will update the group and set the parent if it exists. Create it and set the parent if the group doesnâ€™t exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmGroupsPostRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsPost(ctx context.Context, realm string) ApiAdminRealmsRealmGroupsPostRequest {
	return ApiAdminRealmsRealmGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsPostExecute(r ApiAdminRealmsRealmGroupsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
