/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ClientsAPIService ClientsAPI service
type ClientsAPIService service

type ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretGetRequest) Execute() (*CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretGet Get the client secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return CredentialRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretGetRequest) (*CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretPostRequest) Execute() (*CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretPost Generate a new secret for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretPost(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretPostRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return CredentialRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretPostExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretPostRequest) (*CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretRotatedDelete Invalidate the rotated secret for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedDelete(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretRotatedDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret/rotated"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest) Execute() (*CredentialRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidClientSecretRotatedGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidClientSecretRotatedGet Get the rotated client secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return CredentialRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidClientSecretRotatedGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest) (*CredentialRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CredentialRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidClientSecretRotatedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/client-secret/rotated"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete Method for AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientUuid string, clientScopeId string) ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut Method for AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut(ctx context.Context, realm string, clientUuid string, clientScopeId string) ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDefaultClientScopesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDefaultClientScopesGet Get default client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDefaultClientScopesGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDefaultClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidDelete Delete the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDelete(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidDeleteRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidDeleteExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
	userId *string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) Scope(scope string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest {
	r.scope = &scope
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) UserId(userId string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest {
	r.userId = &userId
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) Execute() (*AccessToken, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet Create JSON with payload of example access token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return AccessToken
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest) (*AccessToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-access-token"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
	userId *string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) Scope(scope string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest {
	r.scope = &scope
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) UserId(userId string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest {
	r.userId = &userId
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) Execute() (*IDToken, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet Create JSON with payload of example id token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return IDToken
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest) (*IDToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IDToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-id-token"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
	userId *string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) Scope(scope string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest {
	r.scope = &scope
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) UserId(userId string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest {
	r.userId = &userId
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet Create JSON with payload of example user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-userinfo"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	scope *string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest) Scope(scope string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest {
	r.scope = &scope
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest) Execute() ([]ProtocolMapperEvaluationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet Return list of all protocol mappers, which will be used when generating tokens issued for particular client.

This means protocol mappers assigned to this client directly and protocol mappers assigned to all client scopes of this client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []ProtocolMapperEvaluationRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest) ([]ProtocolMapperEvaluationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProtocolMapperEvaluationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/protocol-mappers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	roleContainerId string
	scope *string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest) Scope(scope string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest {
	r.scope = &scope
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.

This contains scope mappings, which this client has directly, as well as scope mappings, which are granted to all client scopes, which are linked with this client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleContainerId either realm name OR client UUID
 @return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(ctx context.Context, realm string, clientUuid string, roleContainerId string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleContainerId: roleContainerId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/scope-mappings/{roleContainerId}/granted"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleContainerId"+"}", url.PathEscape(parameterValueToString(r.roleContainerId, "roleContainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	roleContainerId string
	scope *string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest) Scope(scope string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest {
	r.scope = &scope
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet Get roles, which this client doesn't have scope for and can't have them in the accessToken issued for him.

Defacto all the other roles of particular role container, which are not in {@link #getGrantedScopeMappings()}

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param roleContainerId either realm name OR client UUID
 @return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(ctx context.Context, realm string, clientUuid string, roleContainerId string) ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		roleContainerId: roleContainerId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/scope-mappings/{roleContainerId}/not-granted"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleContainerId"+"}", url.PathEscape(parameterValueToString(r.roleContainerId, "roleContainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidGetRequest) Execute() (*ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidGet Get representation of the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ClientRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidGetRequest) (*ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	providerId string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet Method for AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param providerId
 @return ClientsAPIAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet(ctx context.Context, realm string, clientUuid string, providerId string) ClientsAPIAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		providerId: providerId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/installation/providers/{providerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"providerId"+"}", url.PathEscape(parameterValueToString(r.providerId, "providerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidManagementPermissionsGet Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	managementPermissionReference *ManagementPermissionReference
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidManagementPermissionsPut Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsPut(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidManagementPermissionsPutExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	node string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidNodesNodeDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidNodesNodeDelete Unregister a cluster node from the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param node
 @return ClientsAPIAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesNodeDelete(ctx context.Context, realm string, clientUuid string, node string) ClientsAPIAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		node: node,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesNodeDeleteExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidNodesNodeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidNodesNodeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/nodes/{node}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	requestBody *map[string]string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest) RequestBody(requestBody map[string]string) ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidNodesPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidNodesPost Register a cluster node with the client Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle by sending registration request to Keycloak

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesPost(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidNodesPostExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidNodesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidNodesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOfflineSessionCountGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOfflineSessionCountGet Get application offline session count Returns a number of offline user sessions associated with this client { \"count\": number }

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionCountGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionCountGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOfflineSessionCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/offline-session-count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	first *int32
	max *int32
}

// Paging offset
func (r ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) First(first int32) ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) Max(max int32) ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest {
	r.max = &max
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOfflineSessionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOfflineSessionsGet Get offline sessions for client Returns a list of offline user sessions associated with this client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionsGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []UserSessionRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOfflineSessionsGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidOfflineSessionsGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOfflineSessionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/offline-sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete Method for AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete(ctx context.Context, realm string, clientUuid string, clientScopeId string) ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientScopeId string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut Method for AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @param clientScopeId
 @return ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut(ctx context.Context, realm string, clientUuid string, clientScopeId string) ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
		clientScopeId: clientScopeId,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes/{clientScopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientScopeId"+"}", url.PathEscape(parameterValueToString(r.clientScopeId, "clientScopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest) Execute() ([]ClientScopeRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidOptionalClientScopesGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidOptionalClientScopesGet Get optional client scopes.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []ClientScopeRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidOptionalClientScopesGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest) ([]ClientScopeRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientScopeRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidOptionalClientScopesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidPushRevocationPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidPushRevocationPostRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidPushRevocationPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidPushRevocationPost Push the client's revocation policy to its admin URL If the client has an admin URL, push revocation policy to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidPushRevocationPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPushRevocationPost(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidPushRevocationPostRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidPushRevocationPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPushRevocationPostExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidPushRevocationPostRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidPushRevocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/push-revocation"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	clientRepresentation *ClientRepresentation
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest) ClientRepresentation(clientRepresentation ClientRepresentation) ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest {
	r.clientRepresentation = &clientRepresentation
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidPutExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidPut Update the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPut(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidPutExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest) Execute() (*ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPost Generate a new registration access token for the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPost(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return ClientRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest) (*ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidRegistrationAccessTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/registration-access-token"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest) Execute() (*UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidServiceAccountUserGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidServiceAccountUserGet Get a user dedicated to the service account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidServiceAccountUserGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return UserRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidServiceAccountUserGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidServiceAccountUserGetRequest) (*UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidServiceAccountUserGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/service-account-user"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidSessionCountGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidSessionCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidSessionCountGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidSessionCountGet Get application session count Returns a number of user sessions associated with this client { \"count\": number }

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidSessionCountGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidSessionCountGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidSessionCountGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidSessionCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidSessionCountGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidSessionCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidSessionCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/session-count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest) Execute() (*GlobalRequestResult, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidTestNodesAvailableGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidTestNodesAvailableGet Test if registered cluster nodes are available Tests availability by sending 'ping' request to all cluster nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidTestNodesAvailableGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return GlobalRequestResult
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidTestNodesAvailableGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest) (*GlobalRequestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalRequestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidTestNodesAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/test-nodes-available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientUuid string
	first *int32
	max *int32
}

// Paging offset
func (r ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) First(first int32) ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) Max(max int32) ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest {
	r.max = &max
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) Execute() ([]UserSessionRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsClientUuidUserSessionsGetExecute(r)
}

/*
AdminRealmsRealmClientsClientUuidUserSessionsGet Get user sessions for client Returns a list of user sessions associated with this client 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param clientUuid id of client (not client-id!)
 @return ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidUserSessionsGet(ctx context.Context, realm string, clientUuid string) ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest {
	return ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//  @return []UserSessionRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsClientUuidUserSessionsGetExecute(r ClientsAPIAdminRealmsRealmClientsClientUuidUserSessionsGetRequest) ([]UserSessionRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserSessionRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsClientUuidUserSessionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients/{client-uuid}/user-sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client-uuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsGetRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientId *string
	first *int32
	max *int32
	q *string
	search *bool
	viewableOnly *bool
}

// filter by clientId
func (r ClientsAPIAdminRealmsRealmClientsGetRequest) ClientId(clientId string) ClientsAPIAdminRealmsRealmClientsGetRequest {
	r.clientId = &clientId
	return r
}

// the first result
func (r ClientsAPIAdminRealmsRealmClientsGetRequest) First(first int32) ClientsAPIAdminRealmsRealmClientsGetRequest {
	r.first = &first
	return r
}

// the max results to return
func (r ClientsAPIAdminRealmsRealmClientsGetRequest) Max(max int32) ClientsAPIAdminRealmsRealmClientsGetRequest {
	r.max = &max
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsGetRequest) Q(q string) ClientsAPIAdminRealmsRealmClientsGetRequest {
	r.q = &q
	return r
}

// whether this is a search query or a getClientById query
func (r ClientsAPIAdminRealmsRealmClientsGetRequest) Search(search bool) ClientsAPIAdminRealmsRealmClientsGetRequest {
	r.search = &search
	return r
}

// filter clients that cannot be viewed in full by admin
func (r ClientsAPIAdminRealmsRealmClientsGetRequest) ViewableOnly(viewableOnly bool) ClientsAPIAdminRealmsRealmClientsGetRequest {
	r.viewableOnly = &viewableOnly
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsGetRequest) Execute() ([]ClientRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsGetExecute(r)
}

/*
AdminRealmsRealmClientsGet Get clients belonging to the realm.

If a client can’t be retrieved from the storage due to a problem with the underlying storage, it is silently removed from the returned list. This ensures that concurrent modifications to the list don’t prevent callers from retrieving this list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ClientsAPIAdminRealmsRealmClientsGetRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsGet(ctx context.Context, realm string) ClientsAPIAdminRealmsRealmClientsGetRequest {
	return ClientsAPIAdminRealmsRealmClientsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []ClientRepresentation
func (a *ClientsAPIService) AdminRealmsRealmClientsGetExecute(r ClientsAPIAdminRealmsRealmClientsGetRequest) ([]ClientRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClientRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientId", r.clientId, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	} else {
		var defaultValue bool = false
		r.search = &defaultValue
	}
	if r.viewableOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewableOnly", r.viewableOnly, "")
	} else {
		var defaultValue bool = false
		r.viewableOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ClientsAPIAdminRealmsRealmClientsPostRequest struct {
	ctx context.Context
	ApiService *ClientsAPIService
	realm string
	clientRepresentation *ClientRepresentation
}

func (r ClientsAPIAdminRealmsRealmClientsPostRequest) ClientRepresentation(clientRepresentation ClientRepresentation) ClientsAPIAdminRealmsRealmClientsPostRequest {
	r.clientRepresentation = &clientRepresentation
	return r
}

func (r ClientsAPIAdminRealmsRealmClientsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmClientsPostExecute(r)
}

/*
AdminRealmsRealmClientsPost Create a new client Client’s client_id must be unique!

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ClientsAPIAdminRealmsRealmClientsPostRequest
*/
func (a *ClientsAPIService) AdminRealmsRealmClientsPost(ctx context.Context, realm string) ClientsAPIAdminRealmsRealmClientsPostRequest {
	return ClientsAPIAdminRealmsRealmClientsPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *ClientsAPIService) AdminRealmsRealmClientsPostExecute(r ClientsAPIAdminRealmsRealmClientsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientsAPIService.AdminRealmsRealmClientsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
