/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AuthenticationManagementAPIService AuthenticationManagementAPI service
type AuthenticationManagementAPIService service

type ApiAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationAuthenticatorProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationAuthenticatorProvidersGet Get authenticator providers Returns a stream of authenticator providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationAuthenticatorProvidersGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest {
	return ApiAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationAuthenticatorProvidersGetExecute(r ApiAdminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationAuthenticatorProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/authenticator-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGet Get client authenticator providers Returns a stream of client authenticator providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest {
	return ApiAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetExecute(r ApiAdminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationClientAuthenticatorProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/client-authenticator-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	providerId string
}

func (r ApiAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest) Execute() (*AuthenticatorConfigInfoRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGet Get authenticator provider's configuration description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param providerId
 @return ApiAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGet(ctx context.Context, realm string, providerId string) ApiAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest {
	return ApiAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		providerId: providerId,
	}
}

// Execute executes the request
//  @return AuthenticatorConfigInfoRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetExecute(r ApiAdminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest) (*AuthenticatorConfigInfoRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticatorConfigInfoRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigDescriptionProviderIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config-description/{providerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"providerId"+"}", url.PathEscape(parameterValueToString(r.providerId, "providerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationConfigIdDeleteRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	id string
}

func (r ApiAdminRealmsRealmAuthenticationConfigIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigIdDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigIdDelete Delete authenticator configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param id Configuration id
 @return ApiAdminRealmsRealmAuthenticationConfigIdDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdDelete(ctx context.Context, realm string, id string) ApiAdminRealmsRealmAuthenticationConfigIdDeleteRequest {
	return ApiAdminRealmsRealmAuthenticationConfigIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		id: id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdDeleteExecute(r ApiAdminRealmsRealmAuthenticationConfigIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationConfigIdGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	id string
}

func (r ApiAdminRealmsRealmAuthenticationConfigIdGetRequest) Execute() (*AuthenticatorConfigRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigIdGet Get authenticator configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param id Configuration id
 @return ApiAdminRealmsRealmAuthenticationConfigIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdGet(ctx context.Context, realm string, id string) ApiAdminRealmsRealmAuthenticationConfigIdGetRequest {
	return ApiAdminRealmsRealmAuthenticationConfigIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		id: id,
	}
}

// Execute executes the request
//  @return AuthenticatorConfigRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdGetExecute(r ApiAdminRealmsRealmAuthenticationConfigIdGetRequest) (*AuthenticatorConfigRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticatorConfigRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationConfigIdPutRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	id string
	authenticatorConfigRepresentation *AuthenticatorConfigRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationConfigIdPutRequest) AuthenticatorConfigRepresentation(authenticatorConfigRepresentation AuthenticatorConfigRepresentation) ApiAdminRealmsRealmAuthenticationConfigIdPutRequest {
	r.authenticatorConfigRepresentation = &authenticatorConfigRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationConfigIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigIdPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigIdPut Update authenticator configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param id Configuration id
 @return ApiAdminRealmsRealmAuthenticationConfigIdPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdPut(ctx context.Context, realm string, id string) ApiAdminRealmsRealmAuthenticationConfigIdPutRequest {
	return ApiAdminRealmsRealmAuthenticationConfigIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		id: id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigIdPutExecute(r ApiAdminRealmsRealmAuthenticationConfigIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationConfigPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	authenticatorConfigRepresentation *AuthenticatorConfigRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationConfigPostRequest) AuthenticatorConfigRepresentation(authenticatorConfigRepresentation AuthenticatorConfigRepresentation) ApiAdminRealmsRealmAuthenticationConfigPostRequest {
	r.authenticatorConfigRepresentation = &authenticatorConfigRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationConfigPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationConfigPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationConfigPost Create new authenticator configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationConfigPostRequest

Deprecated
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigPost(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationConfigPostRequest {
	return ApiAdminRealmsRealmAuthenticationConfigPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
// Deprecated
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationConfigPostExecute(r ApiAdminRealmsRealmAuthenticationConfigPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationConfigPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	executionId string
	id string
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest) Execute() (*AuthenticatorConfigRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet Get execution's configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param executionId Execution id
 @param id Configuration id
 @return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest

Deprecated
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet(ctx context.Context, realm string, executionId string, id string) ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest {
	return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		executionId: executionId,
		id: id,
	}
}

// Execute executes the request
//  @return AuthenticatorConfigRepresentation
// Deprecated
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetExecute(r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest) (*AuthenticatorConfigRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticatorConfigRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/config/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	executionId string
	authenticatorConfigRepresentation *AuthenticatorConfigRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest) AuthenticatorConfigRepresentation(authenticatorConfigRepresentation AuthenticatorConfigRepresentation) ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest {
	r.authenticatorConfigRepresentation = &authenticatorConfigRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost Update execution with new configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param executionId Execution id
 @return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost(ctx context.Context, realm string, executionId string) ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest {
	return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostExecute(r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorConfigRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	executionId string
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdDelete Delete execution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param executionId Execution id
 @return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdDelete(ctx context.Context, realm string, executionId string) ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest {
	return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteExecute(r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	executionId string
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdGet Get Single Execution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param executionId
 @return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdGet(ctx context.Context, realm string, executionId string) ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest {
	return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdGetExecute(r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	executionId string
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost Lower execution's priority

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param executionId Execution id
 @return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost(ctx context.Context, realm string, executionId string) ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest {
	return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostExecute(r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/lower-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	executionId string
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost Raise execution's priority

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param executionId Execution id
 @return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost(ctx context.Context, realm string, executionId string) ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest {
	return ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostExecute(r ApiAdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions/{executionId}/raise-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationExecutionsPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	authenticationExecutionRepresentation *AuthenticationExecutionRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsPostRequest) AuthenticationExecutionRepresentation(authenticationExecutionRepresentation AuthenticationExecutionRepresentation) ApiAdminRealmsRealmAuthenticationExecutionsPostRequest {
	r.authenticationExecutionRepresentation = &authenticationExecutionRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationExecutionsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationExecutionsPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationExecutionsPost Add new authentication execution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationExecutionsPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsPost(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationExecutionsPostRequest {
	return ApiAdminRealmsRealmAuthenticationExecutionsPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationExecutionsPostExecute(r ApiAdminRealmsRealmAuthenticationExecutionsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationExecutionsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationExecutionRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	flowAlias string
	requestBody *map[string]string
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest) RequestBody(requestBody map[string]string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPost Copy existing authentication flow under a new name The new name is given as 'newName' attribute of the passed JSON object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param flowAlias name of the existing authentication flow
 @return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPost(ctx context.Context, realm string, flowAlias string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		flowAlias: flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostExecute(r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasCopyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	flowAlias string
	requestBody *map[string]string
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest) RequestBody(requestBody map[string]string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost Add new authentication execution to a flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param flowAlias Alias of parent flow
 @return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost(ctx context.Context, realm string, flowAlias string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		flowAlias: flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostExecute(r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions/execution"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	flowAlias string
	requestBody *map[string]string
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest) RequestBody(requestBody map[string]string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost Add new flow with new execution to existing flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param flowAlias Alias of parent authentication flow
 @return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost(ctx context.Context, realm string, flowAlias string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		flowAlias: flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostExecute(r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions/flow"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	flowAlias string
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet Get authentication executions for a flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param flowAlias Flow alias
 @return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet(ctx context.Context, realm string, flowAlias string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		flowAlias: flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetExecute(r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	flowAlias string
	authenticationExecutionInfoRepresentation *AuthenticationExecutionInfoRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest) AuthenticationExecutionInfoRepresentation(authenticationExecutionInfoRepresentation AuthenticationExecutionInfoRepresentation) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest {
	r.authenticationExecutionInfoRepresentation = &authenticationExecutionInfoRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut Update authentication executions of a Flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param flowAlias Flow alias
 @return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut(ctx context.Context, realm string, flowAlias string) ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		flowAlias: flowAlias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutExecute(r ApiAdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{flowAlias}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowAlias"+"}", url.PathEscape(parameterValueToString(r.flowAlias, "flowAlias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationExecutionInfoRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationFlowsGetRequest) Execute() ([]AuthenticationFlowRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsGet Get authentication flows Returns a stream of authentication flows.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationFlowsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationFlowsGetRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []AuthenticationFlowRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsGetExecute(r ApiAdminRealmsRealmAuthenticationFlowsGetRequest) ([]AuthenticationFlowRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AuthenticationFlowRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsIdDeleteRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	id string
}

func (r ApiAdminRealmsRealmAuthenticationFlowsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsIdDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsIdDelete Delete an authentication flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param id Flow id
 @return ApiAdminRealmsRealmAuthenticationFlowsIdDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdDelete(ctx context.Context, realm string, id string) ApiAdminRealmsRealmAuthenticationFlowsIdDeleteRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		id: id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdDeleteExecute(r ApiAdminRealmsRealmAuthenticationFlowsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsIdGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	id string
}

func (r ApiAdminRealmsRealmAuthenticationFlowsIdGetRequest) Execute() (*AuthenticationFlowRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsIdGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsIdGet Get authentication flow for id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param id Flow id
 @return ApiAdminRealmsRealmAuthenticationFlowsIdGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdGet(ctx context.Context, realm string, id string) ApiAdminRealmsRealmAuthenticationFlowsIdGetRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		id: id,
	}
}

// Execute executes the request
//  @return AuthenticationFlowRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdGetExecute(r ApiAdminRealmsRealmAuthenticationFlowsIdGetRequest) (*AuthenticationFlowRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticationFlowRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	id string
	authenticationFlowRepresentation *AuthenticationFlowRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest) AuthenticationFlowRepresentation(authenticationFlowRepresentation AuthenticationFlowRepresentation) ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest {
	r.authenticationFlowRepresentation = &authenticationFlowRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsIdPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsIdPut Update an authentication flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param id
 @return ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdPut(ctx context.Context, realm string, id string) ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		id: id,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsIdPutExecute(r ApiAdminRealmsRealmAuthenticationFlowsIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationFlowRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFlowsPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	authenticationFlowRepresentation *AuthenticationFlowRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationFlowsPostRequest) AuthenticationFlowRepresentation(authenticationFlowRepresentation AuthenticationFlowRepresentation) ApiAdminRealmsRealmAuthenticationFlowsPostRequest {
	r.authenticationFlowRepresentation = &authenticationFlowRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationFlowsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFlowsPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationFlowsPost Create a new authentication flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationFlowsPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsPost(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationFlowsPostRequest {
	return ApiAdminRealmsRealmAuthenticationFlowsPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFlowsPostExecute(r ApiAdminRealmsRealmAuthenticationFlowsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFlowsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationFlowRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFormActionProvidersGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationFormActionProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFormActionProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFormActionProvidersGet Get form action providers Returns a stream of form action providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationFormActionProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormActionProvidersGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationFormActionProvidersGetRequest {
	return ApiAdminRealmsRealmAuthenticationFormActionProvidersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormActionProvidersGetExecute(r ApiAdminRealmsRealmAuthenticationFormActionProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFormActionProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/form-action-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationFormProvidersGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationFormProvidersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationFormProvidersGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationFormProvidersGet Get form providers Returns a stream of form providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationFormProvidersGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormProvidersGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationFormProvidersGetRequest {
	return ApiAdminRealmsRealmAuthenticationFormProvidersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationFormProvidersGetExecute(r ApiAdminRealmsRealmAuthenticationFormProvidersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationFormProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/form-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest) Execute() (*map[string][]ConfigPropertyRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationPerClientConfigDescriptionGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationPerClientConfigDescriptionGet Get configuration descriptions for all clients

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationPerClientConfigDescriptionGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest {
	return ApiAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return map[string][]ConfigPropertyRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationPerClientConfigDescriptionGetExecute(r ApiAdminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest) (*map[string][]ConfigPropertyRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string][]ConfigPropertyRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationPerClientConfigDescriptionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/per-client-config-description"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	requestBody *map[string]string
}

func (r ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest) RequestBody(requestBody map[string]string) ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRegisterRequiredActionPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationRegisterRequiredActionPost Register a new required actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRegisterRequiredActionPost(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest {
	return ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRegisterRequiredActionPostExecute(r ApiAdminRealmsRealmAuthenticationRegisterRequiredActionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRegisterRequiredActionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/register-required-action"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	alias string
}

func (r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasDeleteExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasDelete Delete required action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param alias Alias of required action
 @return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasDelete(ctx context.Context, realm string, alias string) ApiAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest {
	return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		alias: alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasDeleteExecute(r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	alias string
}

func (r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest) Execute() (*RequiredActionProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasGet Get required action for alias

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param alias Alias of required action
 @return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasGet(ctx context.Context, realm string, alias string) ApiAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest {
	return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		alias: alias,
	}
}

// Execute executes the request
//  @return RequiredActionProviderRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasGetExecute(r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasGetRequest) (*RequiredActionProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RequiredActionProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	alias string
}

func (r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost Lower required action's priority

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param alias Alias of required action
 @return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost(ctx context.Context, realm string, alias string) ApiAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest {
	return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		alias: alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostExecute(r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}/lower-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	alias string
	requiredActionProviderRepresentation *RequiredActionProviderRepresentation
}

func (r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest) RequiredActionProviderRepresentation(requiredActionProviderRepresentation RequiredActionProviderRepresentation) ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest {
	r.requiredActionProviderRepresentation = &requiredActionProviderRepresentation
	return r
}

func (r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasPutExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasPut Update required action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param alias Alias of required action
 @return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasPut(ctx context.Context, realm string, alias string) ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest {
	return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		alias: alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasPutExecute(r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requiredActionProviderRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
	alias string
}

func (r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost Raise required action's priority

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param alias Alias of required action
 @return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost(ctx context.Context, realm string, alias string) ApiAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest {
	return ApiAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		alias: alias,
	}
}

// Execute executes the request
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostExecute(r ApiAdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions/{alias}/raise-priority"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationRequiredActionsGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationRequiredActionsGetRequest) Execute() ([]RequiredActionProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationRequiredActionsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationRequiredActionsGet Get required actions Returns a stream of required actions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationRequiredActionsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationRequiredActionsGetRequest {
	return ApiAdminRealmsRealmAuthenticationRequiredActionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []RequiredActionProviderRepresentation
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationRequiredActionsGetExecute(r ApiAdminRealmsRealmAuthenticationRequiredActionsGetRequest) ([]RequiredActionProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RequiredActionProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationRequiredActionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/required-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest struct {
	ctx context.Context
	ApiService *AuthenticationManagementAPIService
	realm string
}

func (r ApiAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest) Execute() ([]map[string]string, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetExecute(r)
}

/*
AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGet Get unregistered required actions Returns a stream of unregistered required actions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest
*/
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGet(ctx context.Context, realm string) ApiAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest {
	return ApiAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []map[string]string
func (a *AuthenticationManagementAPIService) AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetExecute(r ApiAdminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest) ([]map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationManagementAPIService.AdminRealmsRealmAuthenticationUnregisteredRequiredActionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/authentication/unregistered-required-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
