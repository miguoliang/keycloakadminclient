/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GroupsAPIService GroupsAPI service
type GroupsAPIService service

type GroupsAPIAdminRealmsRealmGroupsCountGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	search *string
	top *bool
}

func (r GroupsAPIAdminRealmsRealmGroupsCountGetRequest) Search(search string) GroupsAPIAdminRealmsRealmGroupsCountGetRequest {
	r.search = &search
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsCountGetRequest) Top(top bool) GroupsAPIAdminRealmsRealmGroupsCountGetRequest {
	r.top = &top
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsCountGetRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsCountGetExecute(r)
}

/*
AdminRealmsRealmGroupsCountGet Returns the groups counts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return GroupsAPIAdminRealmsRealmGroupsCountGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsCountGet(ctx context.Context, realm string) GroupsAPIAdminRealmsRealmGroupsCountGetRequest {
	return GroupsAPIAdminRealmsRealmGroupsCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *GroupsAPIService) AdminRealmsRealmGroupsCountGetExecute(r GroupsAPIAdminRealmsRealmGroupsCountGetRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.top != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top", r.top, "")
	} else {
		var defaultValue bool = false
		r.top = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	briefRepresentation *bool
	exact *bool
	first *int32
	max *int32
	populateHierarchy *bool
	q *string
	search *string
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) BriefRepresentation(briefRepresentation bool) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) Exact(exact bool) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	r.exact = &exact
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) First(first int32) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	r.first = &first
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) Max(max int32) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	r.max = &max
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) PopulateHierarchy(populateHierarchy bool) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	r.populateHierarchy = &populateHierarchy
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) Q(q string) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	r.q = &q
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) Search(search string) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	r.search = &search
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGetExecute(r)
}

/*
AdminRealmsRealmGroupsGet Get group hierarchy.  Only name and ids are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return GroupsAPIAdminRealmsRealmGroupsGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGet(ctx context.Context, realm string) GroupsAPIAdminRealmsRealmGroupsGetRequest {
	return GroupsAPIAdminRealmsRealmGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGetExecute(r GroupsAPIAdminRealmsRealmGroupsGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "")
	} else {
		var defaultValue bool = false
		r.exact = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	if r.populateHierarchy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "populateHierarchy", r.populateHierarchy, "")
	} else {
		var defaultValue bool = true
		r.populateHierarchy = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	briefRepresentation *bool
	first *int32
	max *int32
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest) BriefRepresentation(briefRepresentation bool) GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest) First(first int32) GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	r.first = &first
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest) Max(max int32) GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	r.max = &max
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdChildrenGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdChildrenGet Return a paginated list of subgroups that have a parent group corresponding to the group on the URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenGet(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []GroupRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenGetExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenGetRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdChildrenGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = false
		r.briefRepresentation = &defaultValue
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	groupRepresentation *GroupRepresentation
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest) GroupRepresentation(groupRepresentation GroupRepresentation) GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest {
	r.groupRepresentation = &groupRepresentation
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdChildrenPostExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdChildrenPost Set or create child.

This will just set the parent if it exists. Create it and set the parent if the group doesn’t exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenPost(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdChildrenPostExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdChildrenPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdChildrenPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdDeleteExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdDelete Method for AdminRealmsRealmGroupsGroupIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdDeleteRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdDelete(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdDeleteRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdDeleteExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdGetRequest) Execute() (*GroupRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdGet Method for AdminRealmsRealmGroupsGroupIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdGet(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdGetRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GroupRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdGetExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdGetRequest) (*GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdManagementPermissionsGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdManagementPermissionsGet Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsGet(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsGetExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdManagementPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	managementPermissionReference *ManagementPermissionReference
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdManagementPermissionsPutExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdManagementPermissionsPut Return object stating whether client Authorization permissions have been initialized or not and a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsPut(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ManagementPermissionReference
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdManagementPermissionsPutExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdManagementPermissionsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	briefRepresentation *bool
	first *int32
	max *int32
}

// Only return basic information (only guaranteed to return id, username, created, first and last name, email, enabled state, email verification state, federation link, and access. Note that it means that namely user attributes, required actions, and not before are not returned.)
func (r GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest) BriefRepresentation(briefRepresentation bool) GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// Pagination offset
func (r GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest) First(first int32) GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	r.first = &first
	return r
}

// Maximum results size (defaults to 100)
func (r GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest) Max(max int32) GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	r.max = &max
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdMembersGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdMembersGet Get users Returns a stream of users, filtered according to query parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdMembersGet(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []UserRepresentation
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdMembersGetExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdMembersGetRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdMembersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupId string
	groupRepresentation *GroupRepresentation
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest) GroupRepresentation(groupRepresentation GroupRepresentation) GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest {
	r.groupRepresentation = &groupRepresentation
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdPutExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdPut Update group, ignores subgroups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdPut(ctx context.Context, realm string, groupId string) GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest {
	return GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsGroupIdPutExecute(r GroupsAPIAdminRealmsRealmGroupsGroupIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsGroupIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type GroupsAPIAdminRealmsRealmGroupsPostRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	realm string
	groupRepresentation *GroupRepresentation
}

func (r GroupsAPIAdminRealmsRealmGroupsPostRequest) GroupRepresentation(groupRepresentation GroupRepresentation) GroupsAPIAdminRealmsRealmGroupsPostRequest {
	r.groupRepresentation = &groupRepresentation
	return r
}

func (r GroupsAPIAdminRealmsRealmGroupsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsPostExecute(r)
}

/*
AdminRealmsRealmGroupsPost create or add a top level realm groupSet or create child.

This will update the group and set the parent if it exists. Create it and set the parent if the group doesn’t exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return GroupsAPIAdminRealmsRealmGroupsPostRequest
*/
func (a *GroupsAPIService) AdminRealmsRealmGroupsPost(ctx context.Context, realm string) GroupsAPIAdminRealmsRealmGroupsPostRequest {
	return GroupsAPIAdminRealmsRealmGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AdminRealmsRealmGroupsPostExecute(r GroupsAPIAdminRealmsRealmGroupsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.AdminRealmsRealmGroupsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
