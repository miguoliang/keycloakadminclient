/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloakadminclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RoleMapperAPIService RoleMapperAPI service
type RoleMapperAPIService service

type ApiAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsGet Get role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MappingsRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsGetExecute(r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGet Get realm-level roles that can be mapped

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetExecute(r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGet Get effective realm-level role mappings This will recurse all composite roles to get the result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetExecute(r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDelete Delete realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDelete(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest {
	return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteExecute(r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGet Get realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGet(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest {
	return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetExecute(r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	groupId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPost Add realm-level role mappings to the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param groupId
 @return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPost(ctx context.Context, realm string, groupId string) ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest {
	return ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostExecute(r ApiAdminRealmsRealmGroupsGroupIdRoleMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmGroupsGroupIdRoleMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/groups/{group-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdRoleMappingsGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsGetRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsGet Get role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdRoleMappingsGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdRoleMappingsGetRequest {
	return ApiAdminRealmsRealmUsersUserIdRoleMappingsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return MappingsRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsGetExecute(r ApiAdminRealmsRealmUsersUserIdRoleMappingsGetRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGet Get realm-level roles that can be mapped

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest {
	return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetExecute(r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
	briefRepresentation *bool
}

// if false, return roles with their attributes
func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGet Get effective realm-level role mappings This will recurse all composite roles to get the result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest {
	return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetExecute(r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmCompositeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "")
	} else {
		var defaultValue bool = true
		r.briefRepresentation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmDelete Delete realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmDelete(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest {
	return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteExecute(r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmGetExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmGet Get realm-level role mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmGet(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest {
	return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
//  @return []RoleRepresentation
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmGetExecute(r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmGetRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest struct {
	ctx context.Context
	ApiService *RoleMapperAPIService
	realm string
	userId string
	roleRepresentation *[]RoleRepresentation
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest) RoleRepresentation(roleRepresentation []RoleRepresentation) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmUsersUserIdRoleMappingsRealmPostExecute(r)
}

/*
AdminRealmsRealmUsersUserIdRoleMappingsRealmPost Add realm-level role mappings to the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param userId
 @return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest
*/
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmPost(ctx context.Context, realm string, userId string) ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest {
	return ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		userId: userId,
	}
}

// Execute executes the request
func (a *RoleMapperAPIService) AdminRealmsRealmUsersUserIdRoleMappingsRealmPostExecute(r ApiAdminRealmsRealmUsersUserIdRoleMappingsRealmPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleMapperAPIService.AdminRealmsRealmUsersUserIdRoleMappingsRealmPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/users/{user-id}/role-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
